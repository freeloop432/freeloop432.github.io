
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>社区项目知识点详解 | HARD の 空间</title>
        <meta name="author" content="Hard" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>HARD の 空间</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;HARD の 空间</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1>社区项目知识点详解</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/16
        </span>
        
        <span class="category">
            <a href="/categories/java/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                java
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/java%E9%A1%B9%E7%9B%AE/" style="color: #03a9f4">java项目</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="清笛社区"><a href="#清笛社区" class="headerlink" title="清笛社区"></a>清笛社区</h1><h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>   该项目所实现的论坛网站主要是基于社交网络的在线交流平台。用户可以在该平台上发表自己的帖子、提出问题或分享经验，并与其他用户进行互动和交流。此外，该论坛还提供了登录，注册，关注、点赞、回帖、搜索、分享等功能，方便用户更好地管理和交流信息。</p>
<span id="more"></span>

<h2 id="2-项目亮点"><a href="#2-项目亮点" class="headerlink" title="2.项目亮点"></a>2.项目亮点</h2><p>- 项目构建在Spring Boot+SSM框架之上，并统一的进行了状态管理、事务管理、异常处理；</p>
<p>   - 利用Redis实现了点赞和关注功能；</p>
<p>   - 利用Kafka实现了异步的站内通知；</p>
<p>   - 利用ElasticSearch实现了全文搜索功能，可准确匹配搜索结果，并高亮显示关键词；</p>
<p>   - 利用Caffeine+Redis实现了两级缓存，并优化了热门帖子的访问。</p>
<p>   - 利用Spring Security实现了权限控制，实现了多重角色、URL级别的权限管理；</p>
<p>   - 利用HyperLogLog、Bitmap分别实现了UV、DAU的统计功能，100万用户数据只需*M内存空间；</p>
<p>   - 利用Quartz实现了任务调度功能，并实现了定时计算帖子分数、定时清理垃圾文件等功能；</p>
<p>   - 利用Actuator对应用的Bean、缓存、日志、路径等多个维度进行了监控，并通过自定义的端点对数据库连接进行了监控。</p>
<h2 id="3-主要技术及其架构"><a href="#3-主要技术及其架构" class="headerlink" title="3.主要技术及其架构"></a>3.主要技术及其架构</h2><p>​    <strong>SpringBoot + SpringMVC + Spring Security + MyBatis + Redis + Kafka + ElasticSearch + Thymeleaf</strong></p>
<h2 id="4-开发环境的配置"><a href="#4-开发环境的配置" class="headerlink" title="4.开发环境的配置"></a>4.开发环境的配置</h2><h3 id="1-数据库的配置"><a href="#1-数据库的配置" class="headerlink" title="1.数据库的配置"></a>1.数据库的配置</h3><p>​			在项目文件中的sql目录下，找到数据库文件，然后新建数据库community,采用utf8mb4编码，采用这个编码的原因主要是Mysql里面的utf8不是真正的utf8，Mysql里面的utf8占3个字节，无法实现表情或者图片的存储，所以采用utf8mb4编码，注意我这里的数据库版本是Mysql5.7.46,如果是比我的高的Mysql版本也可以。</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/image-20230508170614892.png" alt="image-20230508170614892"></p>
<p>​			在数据库community中运行这三个sql文件</p>
<img src="%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/image-20230508170727947.png" alt="image-20230508170727947" style="zoom: 67%;" />



<p>到此，开发环境中的数据库配置完成</p>
<h3 id="2-Kafka"><a href="#2-Kafka" class="headerlink" title="2.Kafka"></a>2.Kafka</h3><p>​	在Kafka官网下载，然后解压，在其config目录下修改两个文件，一个sever.properties,另一个是zookeeper.properties,主要是修改里面的log.dirs以及data.dirs，把这两个改到本地的目录上去。然后在kafka目录下右键开出两个命令行，分别启动下面的命令运行即可。</p>
<p><strong>启动zookeeper</strong></p>
<pre><code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties
</code></pre>
<p><strong>启动kafka</strong></p>
<pre><code>bin\windows\kafka-server-start.bat config\server.properties
</code></pre>
<h3 id="3-Elasticsearch"><a href="#3-Elasticsearch" class="headerlink" title="3.Elasticsearch"></a>3.Elasticsearch</h3><p>​	在Elasticsearch官网或者是镜像网站，下载zip文件，解压至本机目录，我这里使用的是6.4.3版本的elasticsearch，同样打开config目录，选择elasticsearch.yml文件打开，修改里面的路径即可。</p>
<pre><code>#
path.data: C:\Users\13418\Desktop\elasticsearch-6.4.3\data
#
#
path.logs: C:\Users\13418\Desktop\elasticsearch-6.4.3\logs
#
</code></pre>
<p>​	修改完成后，点击bin目录下的elasticsearch.bat文件即可开始运行Elasticsearch。</p>
<h3 id="4-Redis"><a href="#4-Redis" class="headerlink" title="4.Redis"></a>4.Redis</h3><p>​	同样，在GitHub上或者其他网站，下载windows版Redis，无需修改，直接点击Redis服务端server运行即可开始运行。</p>
<h2 id="5-数据库字段以及实体类"><a href="#5-数据库字段以及实体类" class="headerlink" title="5.数据库字段以及实体类"></a>5.数据库字段以及实体类</h2><h3 id="1-数据库字段"><a href="#1-数据库字段" class="headerlink" title="1.数据库字段"></a>1.数据库字段</h3><p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/image-20230517094853623.png" alt="image-20230517094853623"></p>
<p>使用 Quartz 进行任务调度时，需要在数据库中创建相应的表。Quartz 使用表来存储已经定义的任务和触发器以及它们的关系，从而实现持久化存储任务调度信息。</p>
<p>一般来说，可以使用 Quartz 提供的 SQL 脚本，在数据库中创建相应的表。Quartz 提供了多种数据库支持，可以根据自己使用的数据库来选择相应的脚本。</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/image-20230517095148600.png" alt="image-20230517095148600"></p>
<p><strong>user表中，各字段的作用如下：</strong></p>
<ul>
<li>id：用户的唯一标识符。</li>
<li>username：用户名。</li>
<li>password：密码。</li>
<li>salt：加密盐。</li>
<li>email：邮箱地址。</li>
<li>type：用户类型。0表示普通用户，1表示超级管理员，2表示版主。</li>
<li>status：用户状态。0表示未激活，1表示已激活。</li>
<li>activation_code：激活码。</li>
<li>header_url：头像URL。</li>
<li>create_time：创建时间。</li>
</ul>
<p>该表用于存储用户信息。</p>
<p><strong>discuss_post表中，各字段的作用如下：</strong></p>
<ul>
<li>id：讨论帖的唯一标识符。</li>
<li>user_id：发帖用户的唯一标识符。</li>
<li>title：讨论帖标题。</li>
<li>content：讨论帖内容。</li>
<li>type：讨论帖类型。0表示普通帖，1表示置顶帖。</li>
<li>status：讨论帖状态。0表示正常，1表示精华，2表示拉黑。</li>
<li>create_time：讨论帖创建时间。</li>
<li>comment_count：讨论帖的评论数量。</li>
<li>score：讨论帖的评分。</li>
</ul>
<p>该表用于存储讨论帖信息。</p>
<p><strong>comment表中，各字段的作用如下：</strong></p>
<ul>
<li>id：评论的唯一标识符。</li>
<li>user_id：评论用户的唯一标识符。</li>
<li>entity_type：实体类型。参考其他表中的type字段。</li>
<li>entity_id：实体ID，与entity_type共同构成实体的唯一标识符。</li>
<li>target_id：若该评论是回复某个评论，则该字段为被回复的评论ID，否则该字段为NULL。</li>
<li>content：评论内容。</li>
<li>status：评论状态。</li>
<li>create_time：评论创建时间。</li>
</ul>
<p>该表用于存储评论信息。</p>
<p><strong>message表中，各字段的作用如下：</strong></p>
<ul>
<li>id：消息的唯一标识符。</li>
<li>from_id：发送者的唯一标识符。</li>
<li>to_id：接收者的唯一标识符。</li>
<li>conversation_id：对话唯一标识符。</li>
<li>content：消息内容。</li>
<li>status：消息状态。</li>
<li>create_time：消息创建时间。</li>
</ul>
<p>该表用于存储用户之间的私信消息。</p>
<p><strong>login_ticket表中，各字段的作用如下：</strong></p>
<ul>
<li>id：登录凭证的唯一标识符。</li>
<li>user_id：用户的唯一标识符。</li>
<li>ticket：登录凭证。</li>
<li>status：登录凭证状态。</li>
<li>expired：登录凭证过期时间。</li>
</ul>
<p>该表用于存储用户的登录凭证信息。</p>
<h3 id="2-实体类"><a href="#2-实体类" class="headerlink" title="2.实体类"></a>2.实体类</h3><img src="%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/image-20230517102231722.png" alt="image-20230517102231722" style="zoom:67%;" />







<h2 id="6-Service层"><a href="#6-Service层" class="headerlink" title="6.Service层"></a>6.Service层</h2><h3 id="1-DiscussPostService"><a href="#1-DiscussPostService" class="headerlink" title="1.DiscussPostService"></a>1.DiscussPostService</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>讨论帖服务类，主要完成以下功能：</p>
<ol>
<li>使用 Caffeine 缓存实现帖子列表和帖子总数的缓存；</li>
<li>实现查询用户的帖子列表和帖子总数的方法，当 userId 为 0 时，使用缓存，否则从数据库中查询；</li>
<li>实现添加帖子的方法，对标题和内容进行 HTML 标签转义和敏感词过滤，并将处理后的数据插入到数据库中；</li>
<li>实现根据帖子 id 查询帖子信息、修改评论数量、修改帖子类型和修改帖子状态等方法。</li>
</ol>
<h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h4><p><strong>整体思路</strong></p>
<p>通过使用 Caffeine 缓存实现帖子列表和帖子总数的缓存，提升系统的性能和响应速度。</p>
<p>系统在访问查询用户的帖子列表和帖子总数的方法时，会首先检查 userId 是否为 0，如果是，则表示用户请求获取所有用户的帖子列表和帖子总数，此时系统将会从 Caffeine 缓存中获取数据，如果缓存中不存在满足条件的数据，它会按照一定的规则或算法从数据库中查询数据，并将查询结果缓存在 Caffeine 缓存中。</p>
<p>同时，为了防止缓存中的数据过期，系统还使用了 expireAfterWrite 方法设置了缓存数据的过期时间。这样，系统就能够很好地兼顾性能和数据的实时性。</p>
<p>在添加帖子的方法中，系统首先对帖子的标题和内容进行 HTML 标签转义和敏感词过滤，以保障数据的安全性和稳定性。然后，它将处理后的帖子数据插入到数据库中，完成帖子的添加。</p>
<p>根据帖子 id 查询帖子信息、修改评论数量、修改帖子类型和修改帖子状态等方法则是直接对数据库进行相应的操作，以满足业务需求和功能实现。</p>
<p>通过使用 Caffeine 缓存技术，该段代码实现了查询和添加帖子的性能优化，在保障数据的实时性和安全性的前提下，提升了系统的性能和用户体验。</p>
<p><strong>关于init方法</strong></p>
<p>​	主要是使用了 Spring 框架提供的 @PostConstruct 注解，在应用启动时自动执行了 init() 方法，在 init() 方法中做了以下几个操作：</p>
<ol>
<li>初始化帖子列表缓存（postListCache）和帖子总数缓存（postRowsCache），这两个缓存是通过 Caffeine 缓存实现的。其中，maximumSize 方法设置缓存最大容量，超过这个容量后就按照一定规则将一部分缓存数据删除；expireAfterWrite 方法设置缓存数据的过期时间，当缓存数据超过这个时间后，Caffeine 会自动将其删除。</li>
<li>为了实现帖子列表缓存和帖子总数缓存的查询功能，使用了 CacheLoader 类并重写了其中的 load() 方法，当缓存中没有满足条件的数据时，会自动调用 load() 方法从数据库中查询相关数据，并将查询结果缓存到 Caffeine 中。这样就避免了频繁访问数据库，提高了系统的性能。</li>
</ol>
<p>具体来说，初始化帖子列表缓存时，还做了一些参数合法性的校验，例如判断传入的 key 是否为空或长度错误，以及根据 key 分离出相应的 offset 和 limit 参数，然后调用 discussPostMapper.selectDiscussPostsByPage() 方法从数据库中查询对应的帖子列表数据。</p>
<p>初始化帖子总数缓存时，直接调用 discussPostMapper.selectDiscussPostCount() 方法从数据库中查询帖子总数。</p>
<p><strong>相关注解</strong></p>
<ol>
<li>@PostConstruct：标记在方法上，表示该方法会在依赖注入完成后自动执行，用于初始化一些需要依赖注入的操作。在本段代码中，@PostConstruct 注解用于初始化帖子列表缓存和帖子总数缓存，使得在应用启动时就能够加载这些数据，提高了系统的性能和请求响应速度。</li>
<li>@Nullable：标记在参数、字段或方法上，表示被标记的元素可以为空值（null）。在本段代码中，@Nullable 注解修饰的是 CacheLoader.load() 方法及其返回值，表示查询结果可能为空，需要进行额外的判空操作。</li>
<li>@NonNull：标记在参数、字段或方法上，表示被标记的元素不能为空值（non-null）。在本段代码中，@NonNull 注解修饰的是 CacheLoader.load() 方法的参数 key 和返回值，表示 key 和查询结果都不能为空，避免了空指针异常的风险。</li>
<li>@Override：标记在方法上，表示该方法重写了相应的父类或接口的方法。在本段代码中，@Override 注解用于重写 CacheLoader.load() 方法，在加载缓存数据时实现了具体的业务逻辑。如果没有正确地重写该方法，将无法正确地加载缓存数据。</li>
<li>@NonNullApi、@NullableApi：标记在包上，表示包下所有元素默认都是非空或nullable的。在本段代码中，虽然没有使用到这两个注解，但当项目需要支持 JSR 305 规范时，可以使用这两个注解在项目级别上指定空指针处理策略，提高代码的可读性和可维护性。</li>
</ol>
<h4 id="3-主要代码"><a href="#3-主要代码" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
@Slf4j
public class DiscussPostService &#123;


    @Autowired
    private DiscussPostMapper discussPostMapper;

    @Autowired
    private SensitiveWordFilter sensitiveWordFilter;

    @Value(&quot;$&#123;caffeine.posts.max-size&#125;&quot;)
    private int maxSize;

    @Value(&quot;$&#123;caffeine.posts.expire-seconds&#125;&quot;)
    private int expireSeconds;
    
    private LoadingCache&lt;String,List&lt;DiscussPost&gt;&gt; postListCache;

    private LoadingCache&lt;Integer,Integer&gt; postRowsCache;

    public static final int SPLIT_SIZE = 2;

    @PostConstruct
    public void init()&#123;
        // 本地缓存(一级缓存)

        // 初始化帖子列表缓存
        postListCache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)
                .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;
                    @Nullable
                    @Override
                    public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception &#123;
                        if (key==null||key.length()==0)&#123;
                            throw new IllegalArgumentException(&quot;参数错误!&quot;);
                        &#125;

                        String[] params = key.split(&quot;:&quot;);

                        if (params==null||params.length!=SPLIT_SIZE)&#123;
                            throw new IllegalArgumentException(&quot;参数错误!&quot;);
                        &#125;

                        int offset = Integer.valueOf(params[0]);
                        int limit = Integer.valueOf(params[1]);
                        // 二级缓存：redis -&gt; mysql
                        log.debug(&quot;load post list from DB.===============================&gt;&gt;&quot;);
                        return discussPostMapper.selectDiscussPostsByPage(0,offset,limit,1);
                    &#125;
                &#125;);

        // 初始化帖子列表缓存
        postRowsCache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)
                .build(new CacheLoader&lt;Integer, Integer&gt;() &#123;
                    @Nullable
                    @Override
                    public Integer load(@NonNull Integer key) throws Exception &#123;
                        // 查询数据库得到数据
                        log.debug(&quot;load post list from DB.================================&gt;&gt;&quot;);
                        return discussPostMapper.selectDiscussPostCount(key);
                    &#125;
                &#125;);
    &#125;

    public List&lt;DiscussPost&gt; findDiscussPostList(int userId,int offset,int limit,int orderMode) &#123;
        if (userId==0&amp;&amp;orderMode==1)&#123;
            return postListCache.get(offset + &quot;:&quot; +limit);
        &#125;
        log.debug(&quot;load post list from DB.================================&gt;&gt;&quot;);
        return discussPostMapper.selectDiscussPostsByPage(userId,offset,limit,orderMode);
    &#125;
    public int findDiscussPostCount(int userId)&#123;
        if (userId==0)&#123;
            return postRowsCache.get(userId);
        &#125;
        log.debug(&quot;load post rows from db.=================================&gt;&gt;&quot;);
        return discussPostMapper.selectDiscussPostCount(userId);
    &#125;

    public int addDiscussPost(DiscussPost post)&#123;
        if (CommonUtil.isEmtpy(post))&#123;
            throw new IllegalArgumentException(&quot;参数不能为空&quot;);
        &#125;
        // 转义html标签
        post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));
        post.setContent(HtmlUtils.htmlEscape(post.getContent()));
        // 过滤敏感词
        post.setTitle(sensitiveWordFilter.filterSensitiveWords(post.getTitle()));
        post.setContent(sensitiveWordFilter.filterSensitiveWords(post.getContent()));
        return discussPostMapper.insertDiscussPost(post);
    &#125;

    public DiscussPost findDiscussPostById(int id)&#123;
        return discussPostMapper.selDiscussPostById(id);
    &#125;

    public int updateCommentCount(int id,int commentCount)&#123;
        return discussPostMapper.updateCommentCount(id,commentCount);
    &#125;

    public int updateType(int id,int type)&#123;
        return discussPostMapper.updateType(id,type);
    &#125;

    public int updateStatus(int id,int status)&#123;
        return discussPostMapper.updateStatus(id,status);
    &#125;

    public int updateScore(int id,double score)&#123;
        return discussPostMapper.updateScore(id,score);
    &#125;
&#125;
</code></pre>
<h3 id="2-UserService"><a href="#2-UserService" class="headerlink" title="2.UserService"></a>2.UserService</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h4><p>用户服务类，主要完成以下功能：</p>
<p>1.根据用户id查询用户信息，可以采用缓存机制，优先从Redis中获取数据，如果没有再从MySQL查询。</p>
<p>2.注册用户。当用户注册时，需要进行非空校验和唯一性校验（账号和邮箱），如果校验通过，则在数据库中插入一条记录。同时，还会发送激活邮件到用户的邮箱。</p>
<p>3.激活账号。当用户点击激活邮件中的链接后，会调用该方法。根据用户id和激活码进行验证，如果验证通过，则在数据库中修改该用户状态为已激活。</p>
<p>4.用户登录。输入用户名和密码，如果校验通过，则生成登录凭证，在Redis中设置该登录凭证的有效期，并将该凭证返回给客户端，客户端需要将该凭证存储在cookie中。</p>
<p>5.退出登录。根据用户传递的凭证，将该凭证在Redis中的状态修改为已退出。</p>
<p>6.更新用户头像。根据用户id更新用户头像信息，同时清除Redis中缓存的该用户信息。</p>
<p>7.根据用户名&#x2F;邮箱查询用户信息。</p>
<p>8.更新用户密码。</p>
<p>9.用户忘记密码，向用户设置的邮箱发送验证码邮件。</p>
<p>10.获取用户权限信息。根据用户类型，返回不同的权限列表。</p>
<p>该类中使用了Redis作为缓存数据库，并集成了模板引擎Thymeleaf和邮件发送工具JavaMail。同时，在类中使用了@Autowired和@Value注解进行依赖注入，并且大量使用了自定义工具类和枚举类型等进行业务逻辑的处理。</p>
<h4 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h4><p><strong>整体思路</strong></p>
<p>1.注册用户。首先进行非空校验和账号&#x2F;邮箱唯一性校验，通过校验后，将用户信息插入到数据库中，并发送激活邮件到用户邮箱中。</p>
<p>2.激活账号。用户通过点击激活邮件中的连接来激活账号，激活成功则将用户状态设为已激活。</p>
<p>3.用户登录。用户输入账号和密码，如果校验通过，则生成登录凭证，在Redis中设置该登录凭证的有效期，并将该凭证返回给客户端，客户端需要将该凭证存储在cookie中。</p>
<p>4.退出登录。根据用户传递的凭证，将该凭证在Redis中的状态修改为已退出。</p>
<p>5.查询用户信息。根据用户id或者用户名、邮箱等条件，从Redis缓存或者MySQL中获取用户信息。</p>
<p>6.更新用户信息。根据用户id或者其他条件，更新用户信息并清除Redis缓存。</p>
<p>7.忘记密码。用户忘记密码时，向用户设置的邮箱发送验证码邮件，用户输入正确的验证码后可以重置密码。</p>
<p>8.获取用户权限。根据用户类型返回不同的权限列表。</p>
<p><strong>关于获取用户权限</strong></p>
<p>在 Spring Security 框架中，授权信息表示用户拥有的权限和角色。<code>public Collection&lt;? extends GrantedAuthority&gt; getAuthorites(int userId)</code>返回一个 <code>Collection&lt;? extends GrantedAuthority&gt;</code> 类型的对象，其中包含了用户的授权信息。</p>
<p>在具体实现中，该方法首先根据输入的用户ID，通过调用 <code>findUserById()</code> 方法来查询用户信息。接着，根据用户类型的不同，添加对应的 <code>GrantedAuthority</code> 权限对象到 <code>list</code> 列表中。</p>
<p>在这里，<code>GrantedAuthority</code> 是 Spring Security 中一个用于存储用户授权信息的接口。在该方法中，通过匿名内部类的方式创建了一个 <code>GrantedAuthority</code> 对象，并实现了其中的 <code>getAuthority()</code> 方法。根据用户类型不同，返回不同的权限字符串，分别为 <code>&quot;admin&quot;</code>、<code>&quot;moderator&quot;</code> 和 <code>&quot;user&quot;</code>。</p>
<p>最后，将创建好的 <code>GrantedAuthority</code> 对象添加到 <code>list</code> 列表中，并返回该列表作为用户的授权信息。</p>
<p><strong>发送邮件</strong></p>
<ol>
<li>创建一个 <code>Context</code> 对象用于存储动态 HTML 邮件中的变量。</li>
<li>使用 <code>context.setVariable()</code> 方法向 <code>Context</code> 对象中添加两个变量，分别是接收验证码的邮箱地址 <code>email</code> 和验证码 <code>verifyCode</code>。</li>
<li>通过调用 <code>templateEngine.process()</code> 方法将 <code>/mail/forget</code> 模板与 <code>context</code> 变量进行结合，生成最终的邮件内容 <code>content</code>。</li>
<li>调用 <code>mailClientConfig.sendMail()</code> 方法，将邮件发送给指定的邮箱地址。其中，“重置密码验证码”是邮件的主题。</li>
</ol>
<p>在具体实现中，<code>templateEngine</code> 是一个由 Spring Boot 提供的模板引擎，在此使用它来处理 HTML 页面的生成。<code>mailClientConfig</code> 则是一个邮件发送客户端，可以将邮件发送到指定的邮箱地址。</p>
<h4 id="3-主要代码-1"><a href="#3-主要代码-1" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class UserService &#123;

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private MailClientConfig mailClientConfig;

    @Autowired
    private TemplateEngine templateEngine;

    @Value(&quot;$&#123;community.path.domain&#125;&quot;)
    private String domain;

    @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)
    private String contextPath;

    /**
     * 根据id查询用户信息
     * @param id
     * @return
     */
    public User findUserById(int id)&#123;
        User user = getUserCache(id);
        if(CommonUtil.isEmtpy(user))&#123;
            user = initCache(id);
        &#125;
        return user;
    &#125;

    /**
     * 注册用户
     * @param user
     * @return
     */
    public Map&lt;String,Object&gt; register(User user)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(10);
        if(user==null)&#123;
            throw new IllegalArgumentException(&quot;用户信息不能为空&quot;);
        &#125;

        // 非空校验
        if(StringUtils.isBlank(user.getUsername()))&#123;
            map.put(&quot;usernameMsg&quot;,&quot;账号不能为空!&quot;);
            return map;
        &#125;

        if(StringUtils.isBlank(user.getPassword()))&#123;
            map.put(&quot;passwordMsg&quot;,&quot;密码不能为空&quot;);
            return map;
        &#125;

        if(StringUtils.isBlank(user.getEmail()))&#123;
            map.put(&quot;emailMsg&quot;,&quot;邮箱不能为空!&quot;);
            return map;
        &#125;

        // 验证用户账号
        User existedUser = userMapper.selectByUserName(user.getUsername());
        if(existedUser!=null)&#123;
            map.put(&quot;usernameMsg&quot;,&quot;该账号已存在&quot;);
            return map;
        &#125;

        // 验证邮箱
        User mailedUser = userMapper.selectByEmail(user.getEmail());
        if(mailedUser!=null)&#123;
            map.put(&quot;emailMsg&quot;,&quot;该邮箱已被注册&quot;);
            return map;
        &#125;

        // 注册用户
        // 设置盐值
        user.setSalt(CommonUtil.generateUUID().substring(0,5));
        user.setPassword(CommonUtil.md5Encode(user.getPassword()+user.getSalt()));
        // 用户类型设置为普通用户类型
        user.setType(0);
        // 用户状态设置为未激活状态
        user.setStatus(0);
        // 设置激活码
        user.setActivationCode(CommonUtil.generateUUID());
        // 设置随机头像
        user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;,new Random().nextInt(1000)));
        user.setCreateTime(new Date());
        userMapper.insertUser(user);

        // 发送激活邮件
        Context context = new Context();
        context.setVariable(&quot;email&quot;,user.getEmail());
        // 设置邮件激活链接 http://localhost:8080/community/activation/&#123;id&#125;/&#123;activationCode&#125;
        String url = domain + contextPath + &quot;/user/activation/&quot; + user.getId() + &quot;/&quot; + user.getActivationCode();
        context.setVariable(&quot;url&quot;,url);
        String content = templateEngine.process(&quot;/mail/activation&quot;, context);
        mailClientConfig.sendMail(user.getEmail(),&quot;激活账号&quot;,content);
        return map;
    &#125;

    /**
     * 激活账户
     * @param userId
     * @param code
     * @return
     */
    public int activation(int userId,String code)&#123;
        User user = userMapper.selectById(userId);
        if(user.getStatus() == 1)&#123;
            // 重复激活
            return ActivationStatus.ACTIVATION_REPEAT.getCode();
        &#125;else if (user.getActivationCode().equals(code))&#123;
            userMapper.updateStatus(userId,1);
            clearCache(userId);
            return ActivationStatus.ACTIVATION_SUCCESS.getCode();
        &#125;else&#123;
            return ActivationStatus.ACTIVATION_FAILURE.getCode();
        &#125;
    &#125;

    /**
     * 用户登录
     * @param username
     * @param password
     * @param expiredSeconds
     * @return
     */
    public Map&lt;String, Object&gt; login(String username,String password,int expiredSeconds)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(10);

        // 空值处理
        if(StringUtils.isBlank(username))&#123;
            map.put(&quot;usernameMsg&quot;,&quot;账号不能为空&quot;);
            return map;
        &#125;

        if(StringUtils.isBlank(password))&#123;
            map.put(&quot;passwordMsg&quot;,&quot;密码不能为空&quot;);
            return map;
        &#125;

        // 验证账号
        User user = userMapper.selectByUserName(username);
        if(user == null)&#123;
            map.put(&quot;usernameMsg&quot;,&quot;账号不存在&quot;);
            return map;
        &#125;

        //验证状态
        if(user.getStatus()==0)&#123;
            map.put(&quot;usernameMsg&quot;,&quot;该账号未激活&quot;);
            return map;
        &#125;

        // 验证密码
        password = CommonUtil.md5Encode(password+user.getSalt());
        if(!user.getPassword().equals(password))&#123;
            map.put(&quot;passwordMsg&quot;,&quot;密码不正确&quot;);
            return map;
        &#125;

        // 生成登录凭证
        LoginTicket loginTicket = new LoginTicket();
        loginTicket.setUserId(user.getId());
        loginTicket.setTicket(CommonUtil.generateUUID());
        loginTicket.setStatus(0);
        loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));

        String ticketKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());
        redisTemplate.opsForValue().set(ticketKey,loginTicket);

        map.put(&quot;ticket&quot;,loginTicket.getTicket());
        return map;
    &#125;

    /**
     * 退出登录
     * @param ticket
     */
    public void logout(String ticket)&#123;
        String ticketKey = RedisKeyUtil.getTicketKey(ticket);
        LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(ticketKey);
        loginTicket.setStatus(1);
        redisTemplate.opsForValue().set(ticketKey,loginTicket);
    &#125;



    /**
     * 用户更新头像
     * @param userId
     * @param headerUrl
     * @return
     */
    public int updateHeader(int userId,String headerUrl)&#123;
        int rows = userMapper.updateHeader(userId, headerUrl);
        clearCache(userId);
        return rows;
    &#125;


    /**
     * 根据用户名查询用户信息
     * @param username
     * @return
     */
    public User findUserByUserName(String username)&#123;
        return userMapper.selectByUserName(username);
    &#125;

    /**
     * 更新用户密码
     * @param user
     * @return
     */
    public int updatePassword(User user)&#123;
        int rows = userMapper.updatePassword(user.getId(), user.getPassword());
        clearCache(user.getId());
        return rows;
    &#125;

    /**
     * 根据邮箱查询用户信息
     * @param email
     * @return
     */
    public User findUserByEmail(String email)&#123;
        return userMapper.selectByEmail(email);
    &#125;

    /**
     * 忘记密码-向用户邮箱发送验证码邮件
     * @param verifyCode
     * @param email
     */
    public void sendVerifyEmail(String verifyCode,String email)&#123;
        Context context = new Context();
        // 设置动态html邮件变量
        context.setVariable(&quot;email&quot;,email);
        context.setVariable(&quot;verifyCode&quot;,verifyCode);
        // 生成邮件内容
        String content = templateEngine.process(&quot;/mail/forget&quot;, context);
        mailClientConfig.sendMail(email,&quot;重置密码验证码&quot;,content);
    &#125;

    /**
     * redis缓存用户信息
     * 1、查询用户信息时，不先访问MySQL，优先从缓存中取值
     * 2、取不到时初始化缓存数据
     * 3、数据变更时，不要直接更新缓存中的数据这种方式，一是麻烦，二是容易产生并发问题
     * 而是采用清除缓存数据
     */
    private User getUserCache(int userId)&#123;
        String userKey = RedisKeyUtil.getUserKey(userId);
        return (User) redisTemplate.opsForValue().get(userKey);
    &#125;

    private User initCache(int userId)&#123;
        User user = userMapper.selectById(userId);
        String userKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.opsForValue().set(userKey,user,3600, TimeUnit.SECONDS);
        return user;
    &#125;

    private void clearCache(int userId)&#123;
        String userKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.delete(userKey);
    &#125;

    public Collection&lt;? extends GrantedAuthority&gt; getAuthorites(int userId)&#123;
        User user = this.findUserById(userId);

        List&lt;GrantedAuthority&gt; list = new ArrayList&lt;&gt;();
        list.add(new GrantedAuthority() &#123;
            @Override
            public String getAuthority() &#123;
                switch (user.getType())&#123;
                    case 1:
                        return SystemConstant.AUTHORITY_ADMIN;
                    case 2:
                        return SystemConstant.AUTHORITY_MODERATOR;
                    default:
                        return SystemConstant.AUTHORITY_USER;
                &#125;
            &#125;
        &#125;);
        return list;
    &#125;

&#125;
</code></pre>
<h3 id="3-MessageService"><a href="#3-MessageService" class="headerlink" title="3.MessageService"></a>3.MessageService</h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h4><p>消息管理服务类，主要用于封装与消息相关的逻辑操作。具体包括以下功能：</p>
<ol>
<li>分页查询用户私信会话列表：通过调用 <code>messageMapper.selectConversations()</code> 方法，实现对用户私信会话列表的分页查询。</li>
<li>查询用户会话总数：通过调用 <code>messageMapper.selectConversationCount()</code> 方法，实现对用户私信会话总数的查询。</li>
<li>查询用户会话私信条目：通过调用 <code>messageMapper.selectLetters()</code> 方法，实现对用户会话私信条目的查询。</li>
<li>查询用户会话私信记录条数：通过调用 <code>messageMapper.selectLetterCount()</code> 方法，实现对用户会话私信记录条数的查询。</li>
<li>查询用户会话私信未读记录条数：通过调用 <code>messageMapper.selectLetterUnreadCount()</code> 方法，实现对用户会话私信未读记录条数的查询。</li>
<li>添加用户私信记录：通过调用 <code>messageMapper.insertMessage()</code> 方法，实现向数据库中添加用户私信记录的操作。</li>
<li>将私信接收者的私信条目状态变为已读：通过调用 <code>messageMapper.updateStatus()</code> 方法，实现将私信接收者的私信条目状态变为已读的操作。</li>
<li>查找最新的通知：通过调用 <code>messageMapper.selectLatestNotice()</code> 方法，实现查找最新的通知的操作。</li>
<li>查询某一主题下通知的数量：通过调用 <code>messageMapper.selectNoticeCount()</code> 方法，实现查询某一主题下通知的数量的操作。</li>
<li>查询(某一主题下)未读通知的数量：通过调用 <code>messageMapper.selectNoticeUnreadCount()</code> 方法，实现查询(某一主题下)未读通知的数量的操作。</li>
<li>分页查询用户某一主题下的通知列表：通过调用 <code>messageMapper.selectNoticeList()</code> 方法，实现分页查询用户某一主题下的通知列表的操作。</li>
</ol>
<p>引入了敏感词过滤器 <code>SensitiveWordFilter</code>，可以在用户发送私信时对私信内容进行敏感词过滤。同时，还使用了 Spring 框架提供的 <code>HtmlUtils</code> 工具类对私信内容进行 HTML 转义，防止 XSS 攻击。通过业务层的封装，实现了消息管理相关的业务逻辑，并进一步提高了代码的复用性和可维护性。</p>
<h4 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h4><p>整体思路是封装消息管理的业务逻辑。具体来说，它通过调用 <code>MessageMapper</code> 实现对数据库中消息的操作，包括添加、查询、更新等操作，并且根据具体的需求进行了封装和抽象，提供给上层调用。同时，该类还引入了敏感词过滤器和 HTML 转义工具，保证了数据的安全性和有效性。整个类主要由以下几部分组成：</p>
<ol>
<li>成员变量：类成员变量中包含了一个 <code>MessageMapper</code> 类型的对象和一个 <code>SensitiveWordFilter</code> 类型的对象，用于实现数据库操作和敏感词过滤。</li>
<li>分页查询方法：类中提供了多个分页查询方法，用于查询用户私信会话列表、用户会话私信条目、用户某一主题下的通知列表等。</li>
<li>数据统计方法：类中提供了多个数据统计方法，用于查询用户会话总数、用户会话私信记录条数、用户会话私信未读记录条数等。</li>
<li>消息发送与接收方法：类中提供了消息发送和接收相关的方法，包括向数据库中添加用户私信记录、将私信接收者的私信条目状态变为已读等操作。</li>
<li>通知相关方法：类中提供了通知相关的方法，包括查询某一主题下通知的数量、查询某一主题下未读通知的数量、查找最新的通知等操作。</li>
<li>其他方法：类中还提供了一些其他的辅助或工具性质的方法，比如 HTML 转义、敏感词过滤等。</li>
</ol>
<p>该类实现了消息管理相关的业务逻辑，提高了代码的复用性和可维护性。同时，引入敏感词过滤器和 HTML 转义工具也保证了数据的安全性和有效性。</p>
<h4 id="3-主要代码-2"><a href="#3-主要代码-2" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class MessageService &#123;

    @Autowired
    private MessageMapper messageMapper;

    @Autowired
    private SensitiveWordFilter sensitiveWordFilter;

    /**
     * 分页查询用户私信会话列表
     * @param userId
     * @param offset
     * @param limit
     * @return
     */
    public List&lt;Message&gt; findConversations(int userId,int offset,int limit)&#123;
        return messageMapper.selectConversations(userId,offset,limit);
    &#125;

    /**
     * 查询用户会话总数
     * @param userId
     * @return
     */
    public int findConversationCount(int userId)&#123;
        return messageMapper.selectConversationCount(userId);
    &#125;

    /**
     * 查询用户会话私信条目
     * @param conversationId
     * @param offset
     * @param limit
     * @return
     */
    public List&lt;Message&gt; findLetters(String conversationId,int offset,int limit)&#123;
        return messageMapper.selectLetters(conversationId,offset,limit);
    &#125;

    /**
     * 查询用户会话私信记录条数
     * @param conversationId
     * @return
     */
    public int findLetterCount(String conversationId)&#123;
        return messageMapper.selectLetterCount(conversationId);
    &#125;

    /**
     * 查询用户会话私信未读记录条数
     * @param userId
     * @param conversationId
     * @return
     */
    public int findLetterUnreadCount(int userId,String conversationId)&#123;
        return messageMapper.selectLetterUnreadCount(userId,conversationId);
    &#125;

    /**
     * 添加用户私信记录
     * @param message
     * @return
     */
    public int addMessage(Message message)&#123;
        message.setContent(HtmlUtils.htmlEscape(message.getContent()));
        message.setContent(sensitiveWordFilter.filterSensitiveWords(message.getContent()));
        return messageMapper.insertMessage(message);
    &#125;

    /**
     * 将私信接收者的私信条目状态变为已读
     * @param ids
     * @return
     */
    public int readMessage(List&lt;Integer&gt; ids)&#123;
        return messageMapper.updateStatus(ids,1);
    &#125;

    /**
     * 查找最新的通知
     * @param userId
     * @param topic
     * @return
     */
    public Message findLatestNotice(int userId,String topic)&#123;
        return messageMapper.selectLatestNotice(userId,topic);
    &#125;

    /**
     * 查询某一主题下通知的数量
     * @param userId
     * @param topic
     * @return
     */
    public int findNoticeCount(int userId,String topic)&#123;
        return messageMapper.selectNoticeCount(userId,topic);
    &#125;

    /**
     * 查询(某一主题下)未读通知的数量
     * @param userId
     * @param topic
     * @return
     */
    public int findNoticeUnreadCount(int userId,String topic)&#123;
        return messageMapper.selectNoticeUnreadCount(userId,topic);
    &#125;

    /**
     * 分页查询用户某一主题下的通知列表
     * @param userId
     * @param topic
     * @param offset
     * @param limit
     * @return
     */
    public List&lt;Message&gt; findNoticeList(int userId,String topic,int offset,int limit)&#123;
        return messageMapper.selectNoticeList(userId,topic,offset,limit);
    &#125;

&#125;
</code></pre>
<h3 id="4-LoginTicketService"><a href="#4-LoginTicketService" class="headerlink" title="4.LoginTicketService"></a>4.LoginTicketService</h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用"></a>1.作用</h4><p>登录凭证服务层，主要实现了根据用户浏览器cookie携带的ticket查询用户登录凭证的功能。</p>
<p>具体来说，类中包含了一个RedisTemplate类型的成员变量，用于实现与Redis数据库进行交互。在方法中，类通过调用 RedisKeyUtil 类获取 ticket 对应的 key 值，然后通过 redisTemplate 的 opsForValue().get() 方法从 Redis 中获取相应的 LoginTicket 对象。返回的 LoginTicket 对象可以包含了用户的身份认证信息，如用户名、权限等。</p>
<h4 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h4><p>采用了Spring框架提供的@Service注解来标注该类为一个服务类，通过 @Autowired 注解来将 RedisTemplate 对象注入到该类中。在 findLoginTicket 方法中，首先调用 RedisKeyUtil 类生成 ticket 对应的 key 值，然后通过RedisTemplate 的 opsForValue().get() 方法从 Redis 中获取相应的 LoginTicket 对象，并返回该对象。</p>
<h4 id="3-主要代码-3"><a href="#3-主要代码-3" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code>@Service
public class LoginTicketService &#123;


    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 根据用户浏览器cookie携带的ticket查询用户登录凭证
     * @param ticket
     * @return
     */
    public LoginTicket findLoginTicket(String ticket)&#123;
        String ticketKey = RedisKeyUtil.getTicketKey(ticket);
        return (LoginTicket)redisTemplate.opsForValue().get(ticketKey);
    &#125;
&#125;
</code></pre>
<h3 id="5-LikeService"><a href="#5-LikeService" class="headerlink" title="5.LikeService"></a>5.LikeService</h3><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用"></a>1.作用</h4><p>点赞服务类，主要实现了以下方法：</p>
<ol>
<li>like 方法：点赞方法，接收点赞用户id、实体类型、实体id和实体作者id作为参数。该方法使用RedisTemplate实例来执行Redis命令，通过Redis的事务机制实现对点赞操作的原子性保证。</li>
<li>findEntityLikeCount 方法：获取某实体的点赞数量，接收实体类型和实体id作为参数，并返回该实体的点赞数量。</li>
<li>findEntityLikeStatus 方法：查询某人对某实体的点赞状态，接收点赞用户id、实体类型和实体id作为参数。在Redis中，点赞状态通过set类型的数据结构实现，因此使用redisTemplate.opsForSet().isMember()方法判断用户是否点过赞，如果点过赞则返回1，否则返回0。</li>
<li>findUserLikeCount 方法：查询某个用户获得的赞数，接收用户id作为参数。在Redis中，用户获得的赞数通过string 类型的数据结构实现，因此使用redisTemplate.opsForValue().get()方法获取用户获得的点赞数，如果返回null则默认点赞数为0。</li>
</ol>
<p>此类实现了点赞功能，通过使用Redis存储用户点赞信息和点赞数量来提高点赞功能的效率和稳定性。</p>
<h4 id="2-思路-4"><a href="#2-思路-4" class="headerlink" title="2.思路"></a>2.思路</h4><p><strong>整体思路</strong></p>
<p>整体思路是实现点赞功能，并使用Redis作为数据存储介质。具体来说，将点赞的用户id、实体类型、实体id和实体作者id等信息作为参数传入 like 方法中，通过对Redis中存储的点赞信息进行更新，实现点赞功能。同时，为了提高效率和稳定性，该类使用Redis的事务机制实现对点赞操作的原子性保证。</p>
<p>在具体实现过程中，该类使用了 RedisKeyUtil 工具类来生成 Redis 中存储点赞信息的键值，通过 opsForSet() 方法和 opsForValue() 方法访问 Redis 中的 set 和 string 数据结构。另外，该类还实现了查询实体点赞数量、查询某人对某实体的点赞状态以及查询某个用户获得的赞数等功能。以上方法均是通过调用 RedisTemplate 实例提供的opsFor*() 方法实现。</p>
<p><strong>利用Redis事务机制实现点赞原子性</strong></p>
<p>Redis 的事务机制可以保证一组 Redis 命令的原子性，它的基本原理是将要执行的多个命令全部加入到一个队列中，然后将这个队列中的命令一次性提交给 Redis 服务器执行。</p>
<p>Redis 事务的主要步骤包括：</p>
<ol>
<li>开启事务：通过使用 multi() 方法来开启一个事务，之后执行的所有 Redis 命令将被加入到一个命令队列中，而不是立即执行。</li>
<li>执行 Redis 命令：在事务中，我们可以像平常一样执行 Redis 命令，但这些命令不会立即执行，而是加入到事务队列中。</li>
<li>提交事务：在所有的 Redis 命令都执行完毕之后，我们可以使用 exec() 方法来将队列中的所有命令一次性提交给 Redis 服务器执行。Redis 在执行这些命令时，如果其中有一个命令执行失败，则之前执行的所有命令都会被回滚，事务中的所有操作都将不会执行，从而保证了原子性。</li>
<li>取消事务：在事务执行过程中，可以使用 discard() 方法来取消事务，这会清空当前事务队列中的所有命令。</li>
</ol>
<h4 id="3-主要代码-4"><a href="#3-主要代码-4" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class LikeService &#123;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 点赞方法(重构版)
     *  加入一个维度记录点赞数量，在一个方法中执行了两次更新操作，所以整个业务需要保证事务性
     *  redis就需要通过编程式事务实现nosql数据库的事务性
     * @param userId 点赞用户id
     * @param entityType 实体类型
     * @param entityId 实体id
     * @param entityUserId 实体作者id
     */
    public void like(int userId,int entityType,int entityId,int entityUserId)&#123;

        redisTemplate.execute(new SessionCallback() &#123;
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException &#123;
                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);
                // 查询操作不要放在事务里
                Boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);

                // 开启事务
                operations.multi();
                if(isMember)&#123;
                    operations.opsForSet().remove(entityLikeKey,userId);
                    operations.opsForValue().decrement(userLikeKey);
                &#125;else&#123;
                    operations.opsForSet().add(entityLikeKey,userId);
                    operations.opsForValue().increment(userLikeKey);
                &#125;

                // 执行并提交事务
                return redisTemplate.exec();
            &#125;
        &#125;);
    &#125;

    /**
     * 查询某实体点赞的数量
     * @param entityType
     * @param entityId
     * @return
     */
    public long findEntityLikeCount(int entityType,int entityId)&#123;
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().size(entityLikeKey);
    &#125;

    /**
     * 查询某人对某实体的点赞状态
     * @param userId
     * @param entityType
     * @param entityId
     * @return
     */
    public int findEntityLikeStatus(int userId,int entityType,int entityId)&#123;
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? 1 : 0;
    &#125;

    /**
     * 查询某个用户获得的赞
     * @param userId
     * @return
     */
    public int findUserLikeCount(int userId)&#123;
        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);
        Integer userLikeCount = (Integer) redisTemplate.opsForValue().get(userLikeKey);
        return userLikeCount == null ? 0:userLikeCount.intValue();
    &#125;
&#125;
</code></pre>
<h3 id="6-FollowService"><a href="#6-FollowService" class="headerlink" title="6.FollowService"></a>6.FollowService</h3><h4 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h4><p>关注服务类，封装了用户关注和取消关注、查询用户关注的实体数量、查询实体的粉丝数量、查询当前用户是否已经关注该实体、以及查询某个用户关注的人和粉丝等操作。所有的数据都存储在Redis中，使用了RedisTemplate来操作Redis。</p>
<ol>
<li>用户关注：支持用户对其他实体进行关注，例如某用户关注了另一个用户、关注了一个话题等。</li>
<li>取消关注：支持用户对已经关注的实体进行取消关注操作。</li>
<li>查询用户关注的实体数量：可以查询某个用户关注的特定类型实体的总数量，例如查询某个用户所关注的所有其他用户的总数。</li>
<li>查询实体的粉丝数量：可以查询某个实体的所有粉丝数量，例如查询某个话题的所有粉丝数量。</li>
<li>查询当前用户是否已经关注该实体：可以查询当前用户是否已经对某个实体进行了关注操作。</li>
<li>查询某用户关注的人：可以查询某个用户所关注的所有其他用户，以及其关注时间。</li>
<li>查询某用户的粉丝：可以查询某个用户的所有粉丝，以及其关注时间。</li>
</ol>
<h4 id="2-思路-5"><a href="#2-思路-5" class="headerlink" title="2.思路"></a>2.思路</h4><p>服务主要基于Redis的有序集合（sorted set）实现，使用了zadd（添加元素）、zrem（删除元素）、zcard（获取元素数量）和zscore（获取元素的score值）等有序集合相关命令。更具体的来说，当一个用户关注另一个实体时，就将该关注记录加入到”userId:entityType”的有序集合中，其中元素是实体id，score是关注时间。当查询用户关注的实体、实体的粉丝或者当前用户是否已经关注该实体时，就通过查找对应的有序集合来进行操作。</p>
<p>在查询某用户关注的人或者粉丝时，使用了RedisUtil提供的reverseRange方法来获取有序集合中的元素，该方法可以返回倒序排列的元素列表。最后，我们将得到的元素列表转换为对应的实体对象，以及该关注记录的时间，最终返回查询结果。</p>
<h4 id="3-主要代码-5"><a href="#3-主要代码-5" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class FollowService &#123;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private UserService userService;

    @Autowired
    private RedisUtil redisUtil;

    /**
     * 用户关注
     * @param userId
     * @param entityType
     * @param entityId
     */
    public void toFollow(int userId,int entityType,int entityId)&#123;
        redisTemplate.execute(new SessionCallback() &#123;
            @Override
            public Object execute(RedisOperations redisOperations) throws DataAccessException &#123;
                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);

                redisOperations.multi();

                redisOperations.opsForZSet().add(followeeKey,entityId,System.currentTimeMillis());
                redisOperations.opsForZSet().add(followerKey,userId,System.currentTimeMillis());
                return redisOperations.exec();
            &#125;
        &#125;);
    &#125;

    /**
     * 用户取消关注
     * @param userId
     * @param entityType
     * @param entityId
     */
    public void unFollow(int userId,int entityType,int entityId)&#123;
        redisTemplate.execute(new SessionCallback() &#123;
            @Override
            public Object execute(RedisOperations redisOperations) throws DataAccessException &#123;
                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);

                redisOperations.multi();

                redisOperations.opsForZSet().remove(followeeKey,entityId);
                redisOperations.opsForZSet().remove(followerKey,userId);
                return redisOperations.exec();
            &#125;
        &#125;);
    &#125;

    /**
     * 查询用户关注的实体的数量
     * @param userId 用户id
     * @param entityType 实体类型
     * @return
     */
    public long findFolloweeCount(int userId,int entityType)&#123;
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
        return redisTemplate.opsForZSet().zCard(followeeKey);
    &#125;

    /**
     * 查询实体的粉丝数量
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return
     */
    public long findFollowerCount(int entityType,int entityId)&#123;
        String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);
        return redisTemplate.opsForZSet().zCard(followerKey);
    &#125;

    /**
     * 查询当前用户是否已关注该实体
     * @param userId 当前用户id
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return true/false
     */
    public boolean hasFollowed(int userId,int entityType,int entityId)&#123;
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
        return redisTemplate.opsForZSet().score(followeeKey,entityId)!=null;
    &#125;

    /**
     * 查询某用户关注的人
     * @param userId
     * @param offset
     * @param limit
     * @return
     */
    @SuppressWarnings(&quot;all&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId,int offset,int limit)&#123;
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId, CommentEntityConstant.ENTITY_TYPE_USER.getType());
        Set&lt;Integer&gt; targetIds = (Set&lt;Integer&gt;) redisUtil.reverseRange(Integer.class, followeeKey, offset, offset + limit - 1);

        if(CommonUtil.isEmtpy(targetIds))&#123;
            return null;
        &#125;

        List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;();
        for (Integer targetId:targetIds)&#123;
            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
            User user = userService.findUserById(targetId);
            map.put(&quot;user&quot;,user);
            Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);
            map.put(&quot;followTime&quot;,new Date(score.longValue()));
            list.add(map);
        &#125;

        return list;
    &#125;

    /**
     * 查询某用户的粉丝
     * @param userId
     * @param offset
     * @param limit
     * @return
     */
    @SuppressWarnings(&quot;all&quot;)
    public List&lt;Map&lt;String,Object&gt;&gt; findFollowers(int userId,int offset,int limit)&#123;
        String followerKey = RedisKeyUtil.getFollowerKey(CommentEntityConstant.ENTITY_TYPE_USER.getType(), userId);
        Set&lt;Integer&gt; targetIds = (Set&lt;Integer&gt;) redisUtil.reverseRange(Integer.class, followerKey, offset, offset + limit - 1);
        if(CommonUtil.isEmtpy(targetIds))&#123;
            return null;
        &#125;

        List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;();
        for (Integer targetId:targetIds)&#123;
            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
            User user = userService.findUserById(targetId);
            map.put(&quot;user&quot;,user);
            Double score = redisTemplate.opsForZSet().score(followerKey, targetId);
            map.put(&quot;followTime&quot;,new Date(score.longValue()));
            list.add(map);
        &#125;

        return list;
    &#125;

&#125;
</code></pre>
<h3 id="7-DataService"><a href="#7-DataService" class="headerlink" title="7.DataService"></a>7.DataService</h3><h4 id="1-作用-6"><a href="#1-作用-6" class="headerlink" title="1.作用"></a>1.作用</h4><p>UV（Unique Visitor）和DAU（Daily Active User）服务类</p>
<ol>
<li><code>public void recordUv(String ip)</code>：记录指定 IP 的访问行为，统计每日的独立访客（UV）数量。</li>
<li><code>public long calculateUv(Date start, Date end)</code>：统计指定日期范围内的独立访客（UV）数量。</li>
<li><code>public void recordDau(int userId)</code>：记录指定用户的活跃行为，统计每日的活跃用户（DAU）数量。</li>
<li><code>public long calculateDau(Date start, Date end)</code>：统计指定日期范围内的活跃用户（DAU）数量。</li>
</ol>
<h4 id="2-思路-6"><a href="#2-思路-6" class="headerlink" title="2.思路"></a>2.思路</h4><p><strong>主要思路</strong></p>
<p>recordUv() 方法用于记录某个用户在某个时间点上的访问行为，这里使用 HyperLogLog 数据结构来记录每日独立访客数据。该方法通过 Redis 的 opsForHyperLogLog() 方法获取 HyperLogLog 数据类型的 Spring 封装类 HyperLogLogOperations，然后调用其 add() 方法来实现对该日期的 UV 统计。</p>
<p>calculateUv() 方法用于统计指定日期范围内的 UV 数量，该方法会先根据给定的起止日期，整理出这一段时间内每天的 Redis 键，并将这些键作为参数传递给 Redis 中的 union() 方法，合并这些天的 UV 数据。最后，该方法使用 Redis 的 size() 方法返回这段时间内的独立访客数量。</p>
<p>recordDau() 方法用于将某个用户纳入到 DAU 统计中，该方法使用 Redis 的 setBit() 方法，在指定时间点的 Redis 中标记该用户已经活跃。其中，setBit() 方法用于在 Redis 的字符串（String）类型中设置指定位置上的二进制位（bit）为 1 或 0，用来表示该位置上的某个状态。</p>
<p>calculateDau() 方法用于统计指定日期范围内的 DAU 数量，该方法通过 Redis 的 bitCount() 方法获取指定时间段内被标记过的用户数量。为了实现这个统计，该方法先利用 getDailyDauKey() 方法获取指定日期对应的 Redis 键名，并将这些键存入 keyList 中。然后，该方法调用 Redis 的 bitOp() 方法来对这些键进行或（OR）运算，合并这些天的 DAU 数据。最后，该方法使用 Redis 的 bitCount() 方法返回这段时间内的活跃用户数量。</p>
<h4 id="3-主要代码-6"><a href="#3-主要代码-6" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class DataService &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

    /**
     * 将指定的ip记录uv
     * @param ip
     */
    public void recordUv(String ip)&#123;
        String redisKey = RedisKeyUtil.getDailyUvKey(simpleDateFormat.format(new Date()));
        redisTemplate.opsForHyperLogLog().add(redisKey,ip);
    &#125;

    /**
     * 统计指定日期范围内的uv
     * @param start
     * @param end
     * @return
     */
    public long calculateUv(Date start,Date end)&#123;
        if(start == null || end == null)&#123;
            throw new IllegalArgumentException(&quot;参数不能为空&quot;);
        &#125;

        // 整理该日期范围内的key
        List&lt;String&gt; keyList = new ArrayList&lt;&gt;();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end))&#123;
            String dailyUvKey = RedisKeyUtil.getDailyUvKey(simpleDateFormat.format(calendar.getTime()));
            keyList.add(dailyUvKey);
            calendar.add(Calendar.DATE,1);
        &#125;

        // 合并这些天的uv数据
        String rangeUvKey = RedisKeyUtil.getRangeUv(simpleDateFormat.format(start), simpleDateFormat.format(end));
        redisTemplate.opsForHyperLogLog().union(rangeUvKey,keyList.toArray());

        // 返回统计结果
        return redisTemplate.opsForHyperLogLog().size(rangeUvKey);
    &#125;

    /**
     * 将指定用户计入DAU
     * @param userId
     */
    public void recordDau(int userId)&#123;
        String dailyDauKey = RedisKeyUtil.getDailyDauKey(simpleDateFormat.format(new Date()));
        redisTemplate.opsForValue().setBit(dailyDauKey,userId,true);
    &#125;

    /**
     * 统计指定日期范围的Dau
     * @param start
     * @param end
     * @return
     */
    public long calculateDau(Date start,Date end)&#123;
        if (start == null &amp;&amp; end == null)&#123;
            throw new IllegalArgumentException(&quot;参数不能为空&quot;);
        &#125;

        // 整理该日期范围内的key
        List&lt;byte[]&gt; keyList = new ArrayList&lt;&gt;();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end))&#123;
            String dailyDauKey = RedisKeyUtil.getDailyDauKey(simpleDateFormat.format(calendar.getTime()));
            keyList.add(dailyDauKey.getBytes());
            calendar.add(Calendar.DATE,1);
        &#125;

        // 进行Or运算
        return (long) redisTemplate.execute(new RedisCallback() &#123;
            @Override
            public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;
                String rangeDauKey = RedisKeyUtil.getRangeDauKey(simpleDateFormat.format(start), simpleDateFormat.format(end));
                redisConnection.bitOp(RedisStringCommands.BitOperation.OR,rangeDauKey.getBytes(),keyList.toArray(new byte[0][0]));
                return redisConnection.bitCount(rangeDauKey.getBytes());
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<h3 id="8-CommentService"><a href="#8-CommentService" class="headerlink" title="8.CommentService"></a>8.CommentService</h3><h4 id="1-作用-7"><a href="#1-作用-7" class="headerlink" title="1.作用"></a>1.作用</h4><p>评论的服务类，有以下功能：</p>
<ol>
<li><code>findCommentByEntity(int entityType, int entityId, int offset, int limit)</code> 方法用于根据实体类型、实体 ID 以及分页参数来查询帖子的评论信息。该方法通过调用 DAO 层的 <code>selectCommentByEntity()</code> 方法实现。</li>
<li><code>findCommentCount(int entityType, int entityId)</code> 方法用于查询帖子的评论数量。方法通过调用 DAO 层的 <code>selectCountByEntity()</code> 方法实现。</li>
<li><code>addComment(Comment comment)</code> 方法用于添加评论信息。方法会对传入的评论信息进行必要的参数校验，包括：非空判断、评论内容不能为空等；接着会对评论内容进行 HTML 转义以及敏感词过滤，避免评论内容包含恶意代码或不良信息；最后调用 DAO 层的 <code>insertComment()</code> 方法将评论信息插入到数据库中，并更新相应帖子的评论数。当 entityType 为 CommentEntityConstant.ENTITY_TYPE_POST 的时候，还需要调用 discussPostService 中的 updateCommentCount 方法进行评论数量的更新。</li>
<li><code>findReplyInfoList(int userId, int offset, int limit)</code> 方法用于根据用户 ID 和分页参数来查询用户的帖子回复信息列表。方法通过调用 DAO 层的 <code>selectDiscussPostCommentByUserId()</code> 方法实现。</li>
<li><code>findReplyInfoCount(int userId)</code> 方法用于查询用户帖子回复总数。方法通过调用 DAO 层的 <code>selectDiscussPostCommentCount()</code> 方法实现。</li>
<li><code>findCommentById(int id)</code> 方法用于根据评论 ID 查询评论信息。方法通过调用 DAO 层的 <code>selectCommentById()</code> 方法实现。</li>
</ol>
<h4 id="2-思路-7"><a href="#2-思路-7" class="headerlink" title="2.思路"></a>2.思路</h4><p>主要是一个基于评论的服务类，提供了对评论信息的增删改查等方面的操作。</p>
<p>在具体的实现中，该类通过调用 CommentMapper 中的一系列方法来实现各个功能。其中，<code>findCommentByEntity()</code> 和 <code>findCommentCount()</code> 方法用来查询帖子的评论信息和评论数量；<code>addComment()</code> 方法用来添加评论，其中还做了一些参数校验、HTML 转义和敏感词过滤的工作；<code>findReplyInfoList()</code> 和 <code>findReplyInfoCount()</code> 方法对用户的帖子回复信息列表进行查询和统计；而 <code>findCommentById()</code> 方法则主要用来根据评论 ID 查询评论信息。</p>
<p>此外，<code>addComment()</code> 方法中还使用了 @Transactional 注解来开启事务，保证了一次添加评论操作的原子性，同时也避免了 CommentMapper 和 DiscussPostService 之间的数据一致性问题。</p>
<h4 id="3-主要代码-7"><a href="#3-主要代码-7" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class CommentService &#123;

    @Autowired
    private CommentMapper commentMapper;

    @Autowired
    private SensitiveWordFilter sensitiveWordFilter;

    @Autowired
    private DiscussPostService discussPostService;

    /**
     * 分页查询帖子评论信息
     * @param entityType
     * @param entityId
     * @param offset
     * @param limit
     * @return
     */
    public List&lt;Comment&gt; findCommentByEntity(int entityType,int entityId,int offset,int limit)&#123;
        return commentMapper.selectCommentByEntity(entityType,entityId,offset,limit);
    &#125;

    /**
     * 查询帖子评论数量
     * @param entityType
     * @param entityId
     * @return
     */
    public int findCommentCount(int entityType,int entityId)&#123;
        return commentMapper.selectCountByEntity(entityType,entityId);
    &#125;

    /**
     * 添加评论信息
     * @param comment
     * @return
     */
    @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED,rollbackFor = Exception.class)
    public int addComment(Comment comment)&#123;
        if(CommonUtil.isEmtpy(comment))&#123;
            throw new IllegalArgumentException(&quot;参数不能为空&quot;);
        &#125;

        if(StringUtils.isBlank(comment.getContent()))&#123;
            throw new IllegalArgumentException(&quot;评论内容为空&quot;);
        &#125;

        // 添加评论
        comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));
        comment.setContent(sensitiveWordFilter.filterSensitiveWords(comment.getContent()));
        int rows = commentMapper.insertComment(comment);

        // 跟新帖子评论数量
        if(comment.getEntityType() == CommentEntityConstant.ENTITY_TYPE_POST.getType())&#123;
            int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());
            discussPostService.updateCommentCount(comment.getEntityId(),count);
        &#125;

        return rows;
    &#125;

    /**
     * 根据用户id分页查询帖子回复列表
     * @param userId
     * @param offset
     * @param limit
     * @return
     */
    public List&lt;ReplyInfo&gt; findReplyInfoList(int userId,int offset,int limit)&#123;
        return commentMapper.selectDiscussPostCommentByUserId(userId,offset,limit);
    &#125;

    /**
     * 根据用户id查询用户帖子回复总数
     * @param userId
     * @return
     */
    public int findReplyInfoCount(int userId)&#123;
        return commentMapper.selectDiscussPostCommentCount(userId);
    &#125;

    /**
     * 根据id查询评论
     * @param id
     * @return
     */
    public Comment findCommentById(int id)&#123;
        return commentMapper.selectCommentById(id);
    &#125;
&#125;
</code></pre>
<h3 id="9-ElasticsearchService"><a href="#9-ElasticsearchService" class="headerlink" title="9.ElasticsearchService"></a>9.ElasticsearchService</h3><h4 id="1-作用-8"><a href="#1-作用-8" class="headerlink" title="1.作用"></a>1.作用</h4><p>Elasticsearch 的服务类，提供了对帖子信息的增删改查和根据关键字进行搜索的功能。包含以下方法：</p>
<ol>
<li><code>saveDiscussPost(DiscussPost discussPost)</code> ：用于保存或修改一个帖子信息，将传入的 <code>DiscussPost</code> 对象保存到 Elasticsearch 中，调用了 DiscussPostRepository 的 <code>save()</code> 方法实现。</li>
<li><code>deleteDiscusspost(int id)</code> ：用于删除指定 ID 的帖子信息，通过调用 DiscussPostRepository 的 <code>deleteById()</code> 方法实现。</li>
<li><code>updateDiscussPost(DiscussPost discussPost)</code> ：用于更新指定帖子信息，将传入的 <code>DiscussPost</code> 对象更新到 Elasticsearch 中，通过调用 DiscussPostRepository 的 <code>save()</code> 方法实现。</li>
<li><code>searchDiscussPostByCondition(String keyword,int current,int size)</code> ：用于根据关键字和分页信息搜索帖子信息，通过 ElasticsearchTemplate 对 Elasticsearch 进行搜索操作，返回 Page<DiscussPost> 页对象，同时可以支持高亮展示和多种排序方式。</li>
</ol>
<h4 id="2-思路-8"><a href="#2-思路-8" class="headerlink" title="2.思路"></a>2.思路</h4><p>整体思路如下：</p>
<ol>
<li>在 ElasticsearchService 类中，使用 @Autowired 注解注入 ElasticsearchTemplate 和 DiscussPostRepository。</li>
<li>ElasticsearchTemplate 是 Spring 对 Elasticsearch 的封装，可以方便地进行 Elasticsearch 的查询操作。DiscussPostRepository 是一个继承自 ElasticsearchRepository 的接口，用于与 Elasticsearch 进行交互，实现了一系列基本的CRUD操作。</li>
<li><code>saveDiscussPost()</code> 方法用于保存或修改帖子信息，通过调用 DiscussPostRepository 的 save() 方法将传入的 DiscussPost 对象保存到 Elasticsearch 中。</li>
<li><code>deleteDiscusspost()</code> 方法用于删除指定 ID 的帖子信息，通过调用 DiscussPostRepository 的 deleteById() 方法实现。</li>
<li><code>updateDiscussPost()</code> 方法用于更新指定帖子信息，通过调用 DiscussPostRepository 的 save() 方法实现更新。</li>
<li><code>searchDiscussPostByCondition()</code> 方法则是用于执行 Elasticsearch 的搜索操作。具体实现中，该方法使用 ElasticsearchTemplate 查询和处理 Elasticsearch 中的搜索结果，并将其转换成 Page<DiscussPost> 对象返回。同时支持高亮展示和多种排序方式。</li>
<li>在 mapResults() 方法中，重写 SearchResultMapper 接口中的 mapResults() 方法，将 Elasticsearch 返回的数据映射为 JavaBean 对象，并对搜索结果进行特殊处理（如高亮展示等）。</li>
</ol>
<p><strong>问：为什么要同时使用ElasticsearchTemplate 和 DiscussPostRepository</strong></p>
<blockquote>
<p>答：ElasticsearchTemplate 和 DiscussPostRepository 都是 Elasticsearch 在 Spring Boot 中提供的工具类，用于简化 Elasticsearch 的操作。</p>
<p>其中，ElasticsearchTemplate 是 Elasticsearch 官方提供的 Java API 封装，可以用于执行各种复杂的 Elasticsearch 操作，但其代码量比较大，使用起来不太方便。</p>
<p>而 DiscussPostRepository 则是 Spring Data Elasticsearch 提供的一个接口，基于 JPA 规范封装了 Elasticsearch 的常用操作方法，并且提供了一些简单易用的查询方法，如根据 ID 查询、分页查询等，使得 Elasticsearch 的操作更加方便和快速。</p>
<p>因此，使用 ElasticsearchTemplate 和 DiscussPostRepository 两者结合使用，可以各自发挥所长，简化 Elasticsearch 的操作，并且提高 Elasticsearch 的效率和性能。</p>
<p>当然，如果你只需要 Elasticsearch 的部分功能，或者对 Elasticsearch 的操作比较简单，也可以只使用其中的一个。</p>
</blockquote>
<p>其中</p>
<pre><code class="java">@Repository
public interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost,Integer&gt; &#123;


&#125;
</code></pre>
<h4 id="3-主要代码-8"><a href="#3-主要代码-8" class="headerlink" title="3.主要代码"></a>3.主要代码</h4><pre><code class="java">@Service
public class ElasticsearchService &#123;

    @Autowired
    private ElasticsearchTemplate elasticsearchTemplate;

    @Autowired
    private DiscussPostRepository discussPostRepository;

    public void saveDiscussPost(DiscussPost discussPost)&#123;
        discussPostRepository.save(discussPost);
    &#125;

    public void deleteDiscusspost(int id)&#123;
        discussPostRepository.deleteById(id);
    &#125;

    public void updateDiscussPost(DiscussPost discussPost)&#123;
        discussPostRepository.save(discussPost);
    &#125;

    /**
     * 搜索方法
     * @param keyword 搜索关键字
     * @param current 当前页 从0开始
     * @param size 每页条数
     * @return Page&lt;DiscussPost&gt;
     */
    public Page&lt;DiscussPost&gt; searchDiscussPostByCondition(String keyword,int current,int size)&#123;
        SearchQuery searchQuery = new NativeSearchQueryBuilder()
                .withQuery(QueryBuilders.multiMatchQuery(keyword, &quot;title&quot;, &quot;content&quot;))
                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))
                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))
                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))
                .withPageable(PageRequest.of(current, size))
                .withHighlightFields(
                        new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),
                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)
                ).build();

        AggregatedPage&lt;DiscussPost&gt; discussPosts = elasticsearchTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() &#123;
            @Override
            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable) &#123;
                SearchHits hits = searchResponse.getHits();
                if (hits.getTotalHits()&lt;=0)&#123;
                    return null;
                &#125;

                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();
                for (SearchHit hit : hits) &#123;
                    DiscussPost post = new DiscussPost();
                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();
                    post.setId(Integer.parseInt(id));

                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();
                    post.setUserId(Integer.parseInt(userId));

                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();
                    post.setContent(content);

                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();
                    post.setTitle(title);

                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();
                    post.setStatus(Integer.parseInt(status));

                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();
                    post.setCreateTime(new Date(Long.valueOf(createTime)));

                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();
                    post.setCommentCount(Integer.parseInt(commentCount));

                    // 处理高亮显示的结果
                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);
                    if(titleField!=null)&#123;
                        post.setTitle(titleField.getFragments()[0].toString());
                    &#125;

                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);
                    if(contentField!=null)&#123;
                        post.setTitle(contentField.getFragments()[0].toString());
                    &#125;

                    list.add(post);
                &#125;
                return new AggregatedPageImpl(list,pageable,hits.getTotalHits(),searchResponse.getAggregations(),searchResponse.getScrollId());
            &#125;

        &#125;);
        return discussPosts;
    &#125;
&#125;
</code></pre>
<h2 id="7-工具类"><a href="#7-工具类" class="headerlink" title="7.工具类"></a>7.工具类</h2><h3 id="1-CommonUtil"><a href="#1-CommonUtil" class="headerlink" title="1.CommonUtil"></a>1.CommonUtil</h3><p><strong>主要代码</strong></p>
<pre><code class="java">public class CommonUtil &#123;

    private CommonUtil()&#123;

    &#125;

    /**
     * 生成随机字符串
     * @return
     */
    public static String generateUUID()&#123;
        return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);
    &#125;

    /**
     * md5加密方法
     * @param key
     * @return
     */
    public static String md5Encode(String key)&#123;
        if(StringUtils.isBlank(key))&#123;
            return null;
        &#125;
        return DigestUtils.md5DigestAsHex(key.getBytes());
    &#125;

    /**
     * 判断是否为空的方法
     * @param obj
     * @return true/false
     */
    public static boolean isEmtpy(Object obj)
    &#123;
        if (null == obj)
        &#123;
            return true;
        &#125;
        else if (obj instanceof String)
        &#123;
            String str = (String) obj;
            return str.trim().length() == 0;
        &#125;
        else if (obj instanceof Collection)
        &#123;
            Collection&lt;?&gt; coll = (Collection&lt;?&gt;) obj;
            return coll.size() == 0;
        &#125;
        else if (obj instanceof Map)
        &#123;
            Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) obj;
            return map.size() == 0;
        &#125;
        else if (obj.getClass().isArray())
        &#123;
            return Array.getLength(obj) == 0;
        &#125;
        return false;
    &#125;

    /**
     * 获取json字符串
     * @param code 操作码
     * @param msg 提示信息
     * @param map 业务数据
     * @return json字符串
     */
    public static String getJsonString(int code,String msg,Map&lt;String,Object&gt; map)&#123;
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;code&quot;,code);
        jsonObject.put(&quot;msg&quot;,msg);

        if (!isEmtpy(map)) &#123;
            for(String key:map.keySet())&#123;
                jsonObject.put(key,map.get(key));
            &#125;
        &#125;

        return jsonObject.toJSONString();
    &#125;

    /**
     * 获取json字符串方法重载
     * @param code
     * @param msg
     * @return
     */
    public static String getJsonString(int code,String msg)&#123;
        return getJsonString(code,msg,null);
    &#125;

    /**
     * 获取json字符串方法重载
     * @param code
     * @return
     */
    public static String getJsonString(int code)&#123;
        return getJsonString(code,null,null);
    &#125;

    public static String getFormatDate(Date date)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        String formatDateString = sdf.format(date);
        return formatDateString;

    &#125;
</code></pre>
<h3 id="2-CookieUtil"><a href="#2-CookieUtil" class="headerlink" title="2.CookieUtil"></a>2.CookieUtil</h3><p><strong>主要代码</strong></p>
<pre><code class="java">public class CookieUtil &#123;

    private CookieUtil()&#123;

    &#125;

    public static String getValue(HttpServletRequest request,String name)&#123;
        if(request==null||name==null)&#123;
            throw new IllegalArgumentException(&quot;参数为空&quot;);
        &#125;;
        Cookie[] cookies = request.getCookies();
        if(cookies!=null)&#123;
            for (Cookie cookie:cookies)&#123;
                if(cookie.getName().equals(name))&#123;
                    return cookie.getValue();
                &#125;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="3-RedisKeyUtil"><a href="#3-RedisKeyUtil" class="headerlink" title="3.RedisKeyUtil"></a>3.RedisKeyUtil</h3><p><strong>主要代码</strong></p>
<pre><code class="java">public class RedisKeyUtil &#123;

    private static final String SPLIT = &quot;:&quot;;
    private static final String PREFIX_ENTITY_LIKE=&quot;like:entity&quot;;
    private static final String PREFIX_USER_LIKE=&quot;like:user&quot;;
    private static final String PREFIX_FOLLOWER=&quot;follower&quot;;
    private static final String PREFIX_FOLLOWEE=&quot;followee&quot;;
    private static final String PREFIX_KAPTCHA=&quot;kaptcha&quot;;
    private static final String PREFIX_TICKET=&quot;ticket&quot;;
    private static final String PREFIX_USER=&quot;user&quot;;
    private static final String PREFIX_POST=&quot;post&quot;;


    /**
     * 统计网站独立访客数量key
     */
    private static final String PREFIX_UV=&quot;uv&quot;;
    /**
     * 统计网站独立活跃用户数量key
     */
    private static final String PREFIX_UAV=&quot;uav&quot;;


    private RedisKeyUtil()&#123;

    &#125;

    /**
     * 生成某个实体的赞的RedisKey
     *  like:entity:entityType:entityId  ==&gt; set(userId)
     * @param entityType
     * @param entityId
     * @return
     */
    public static String getEntityLikeKey(int entityType,int entityId)&#123;
        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;
    &#125;

    /**
     * 某个用户的赞
     *  like:user:userId -&gt; int
     * @param userId
     * @return
     */
    public static String getUserLikeKey(int userId)&#123;
        return PREFIX_USER_LIKE + SPLIT + userId;
    &#125;

    /**
     * 某个用户关注的实体
     *   followee:userId:entityType -&gt; zset(entityId,now())
     *   使用zset便于排序，使用now当前时间作为score，从而进行排序
     * @param userId
     * @param entityType
     * @return
     */
    public static String getFolloweeKey(int userId,int entityType)&#123;
        return PREFIX_FOLLOWEE + SPLIT +userId +SPLIT +entityType;
    &#125;

    /**
     * 某个实体拥有的粉丝
     *  follower:entityType:entityId -&gt;zset(userId,now)
     * @param entityType
     * @param entityId
     * @return
     */
    public static String getFollowerKey(int entityType,int entityId)&#123;
        return PREFIX_FOLLOWER + SPLIT +entityType + SPLIT + entityId;
    &#125;

    /**
     * 登录验证码key
     * @param owner
     * @return
     */
    public static String getKaptchaKey(String owner)&#123;
        return PREFIX_KAPTCHA + SPLIT + owner;
    &#125;

    /**
     * 登录凭证key
     * @param ticket
     * @return
     */
    public static String getTicketKey(String ticket)&#123;
        return PREFIX_TICKET + SPLIT + ticket;
    &#125;

    /**
     * 用户信息key
     * @param userId
     * @return
     */
    public static String getUserKey(int userId)&#123;
        return PREFIX_USER + SPLIT +userId;
    &#125;

    /**
     * 单日uv
     * @param date
     * @return
     */
    public static String getDailyUvKey(String date)&#123;
        return PREFIX_UV + SPLIT + date;
    &#125;

    /**
     * 获取区间范围的uv
     * @param startDate
     * @param endDate
     * @return
     */
    public static String getRangeUv(String startDate,String endDate)&#123;
        return PREFIX_UV + SPLIT + startDate + SPLIT + endDate;
    &#125;

    /**
     * 单日活跃用户
     * @param date
     * @return
     */
    public static  String getDailyDauKey(String date)&#123;
        return PREFIX_UAV +SPLIT + date;
    &#125;

    /**
     * 区间活跃用户
     * @param startDate
     * @param endDate
     * @return
     */
    public static String getRangeDauKey(String startDate,String endDate)&#123;
        return PREFIX_UAV + SPLIT + startDate + SPLIT + endDate;
    &#125;

    /**
     * 帖子分数
     * @return
     */
    public static String getPostScoreKey()&#123;
        return PREFIX_POST + SPLIT + &quot;score&quot;;
    &#125;

&#125;
</code></pre>
<h3 id="4-RedisUtil"><a href="#4-RedisUtil" class="headerlink" title="4.RedisUtil"></a>4.RedisUtil</h3><pre><code class="java">@Component
public final class RedisUtil &#123;

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    private static double size = Math.pow(2, 32);

    // =============================common============================
    /**
     * 指定缓存失效时间
     * @param key  键
     * @param time 时间(秒)
     */
    public boolean expire(String key, long time) &#123;
        try &#123;
            if (time &gt; 0) &#123;
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key) &#123;
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    &#125;


    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key) &#123;
        try &#123;
            return redisTemplate.hasKey(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void delPatch(String... key) &#123;
        if (key != null &amp;&amp; key.length &gt; 0) &#123;
            if (key.length == 1) &#123;
                redisTemplate.delete(key[0]);
            &#125; else &#123;
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            &#125;
        &#125;
    &#125;

    /**
     * 第一次加载的时候将数据加载到redis中
     * @param name
     */
    public void saveDataToRedis(String name) &#123;
        double index = Math.abs(name.hashCode() % size);
        long indexLong = new Double(index).longValue();
        boolean availableUsers = setBit(&quot;availableUsers&quot;, indexLong, true);
    &#125;

    /**
     * 第一次加载的时候将数据加载到redis中
     * @param name
     * @return
     */
    public boolean getDataToRedis(String name) &#123;

        double index = Math.abs(name.hashCode() % size);
        long indexLong = new Double(index).longValue();
        return getBit(&quot;availableUsers&quot;, indexLong);
    &#125;


    // ============================String=============================

    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key) &#123;
        return key == null ? null : redisTemplate.opsForValue().get(key);
    &#125;

    /**
     * 普通缓存放入
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */

    public boolean set(String key, Object value) &#123;
        try &#123;
            redisTemplate.opsForValue().set(key, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 普通缓存放入并设置时间
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */

    public boolean set(String key, Object value, long time) &#123;
        try &#123;
            if (time &gt; 0) &#123;
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            &#125; else &#123;
                set(key, value);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 写入缓存
     * @param key
     * @param offset 位 8Bit=1Byte
     * @return
     */
    public boolean setBit(String key, long offset, boolean isShow) &#123;
        boolean result = false;
        try &#123;
            ValueOperations&lt;String, Object&gt; operations = redisTemplate.opsForValue();
            operations.setBit(key, offset, isShow);
            result = true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return result;
    &#125;

    /**
     * 写入缓存
     *
     * @param key
     * @param offset
     * @return
     */
    public boolean getBit(String key, long offset) &#123;
        boolean result = false;
        try &#123;
            ValueOperations&lt;String, Object&gt; operations = redisTemplate.opsForValue();
            result = operations.getBit(key, offset);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return result;
    &#125;

    /**
     * 判断缓存中是否有对应的value
     *
     * @param key
     * @return
     */
    public boolean exists(final String key) &#123;
        return redisTemplate.hasKey(key);
    &#125;

    /**
     * 批量删除对应的value
     *
     * @param keys
     */
    public void remove(final String... keys) &#123;
        for (String key : keys) &#123;
            remove(key);
        &#125;
    &#125;


    /**
     * 删除对应的value
     *
     * @param key
     */
    public void remove(final String key) &#123;
        if (exists(key)) &#123;
            redisTemplate.delete(key);
        &#125;
    &#125;



    /**
     * 递增
     * @param key   键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta) &#123;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;


    /**
     * 递减
     * @param key   键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta) &#123;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().increment(key, -delta);
    &#125;


    // ================================Hash=================================

    /**
     * HashGet
     * @param key  键 不能为null
     * @param item 项 不能为null
     */
    public Object hget(String key, String item) &#123;
        return redisTemplate.opsForHash().get(key, item);
    &#125;

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object, Object&gt; hmget(String key) &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;
        try &#123;
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * HashSet 并设置时间
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;
        try &#123;
            redisTemplate.opsForHash().putAll(key, map);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value) &#123;
        try &#123;
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value, long time) &#123;
        try &#123;
            redisTemplate.opsForHash().put(key, item, value);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item) &#123;
        redisTemplate.opsForHash().delete(key, item);
    &#125;


    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item) &#123;
        return redisTemplate.opsForHash().hasKey(key, item);
    &#125;


    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     */
    public double hincr(String key, String item, double by) &#123;
        return redisTemplate.opsForHash().increment(key, item, by);
    &#125;


    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少记(小于0)
     */
    public double hdecr(String key, String item, double by) &#123;
        return redisTemplate.opsForHash().increment(key, item, -by);
    &#125;


    // ============================set=============================

    /**
     * 根据key获取Set中的所有值
     * @param key 键
     */
    public Set&lt;Object&gt; sGet(String key) &#123;
        try &#123;
            return redisTemplate.opsForSet().members(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;


    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) &#123;
        try &#123;
            return redisTemplate.opsForSet().isMember(key, value);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) &#123;
        try &#123;
            return redisTemplate.opsForSet().add(key, values);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;


    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) &#123;
        try &#123;
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time &gt; 0)&#123;
                expire(key, time);
            &#125;
            return count;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;


    /**
     * 获取set缓存的长度
     *
     * @param key 键
     */
    public long sGetSetSize(String key) &#123;
        try &#123;
            return redisTemplate.opsForSet().size(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;


    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */

    public long setRemove(String key, Object... values) &#123;
        try &#123;
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     */
    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;
        try &#123;
            return redisTemplate.opsForList().range(key, start, end);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;


    /**
     * 获取list缓存的长度
     *
     * @param key 键
     */
    public long lGetListSize(String key) &#123;
        try &#123;
            return redisTemplate.opsForList().size(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;


    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     */
    public Object lGetIndex(String key, long index) &#123;
        try &#123;
            return redisTemplate.opsForList().index(key, index);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     */
    public boolean lSet(String key, Object value) &#123;
        try &#123;
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;


    /**
     * 将list放入缓存
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     */
    public boolean lSet(String key, Object value, long time) &#123;
        try &#123;
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0)&#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;

    &#125;


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) &#123;
        try &#123;
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;

    &#125;


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;
        try &#123;
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0)&#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return
     */

    public boolean lUpdateIndex(String key, long index, Object value) &#123;
        try &#123;
            redisTemplate.opsForList().set(key, index, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */

    public long lRemove(String key, long count, Object value) &#123;
        try &#123;
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;

    &#125;

    // =================================ZSet===================================


    /**
     * 有序集合添加
     * @param key
     * @param value
     * @param scoure
     */
    public void zAdd(String key, Object value, double scoure) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        zSet.add(key, value, scoure);
    &#125;

    /**
     * 有序集合获取
     * @param key
     * @param scoure
     * @param scoure1
     * @return
     */
    public Set&lt;Object&gt; rangeByScore(String key, double scoure, double scoure1) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        return zSet.rangeByScore(key, scoure, scoure1);
    &#125;


    /**
     * 有序集合获取排名
     * @param key 集合名称
     * @param value 值
     */
    public Long zRank(String key, Object value) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        return zSet.rank(key,value);
    &#125;


    /**
     * 有序集合获取排名
     * @param key
     */
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; zRankWithScore(String key, long start,long end) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; ret = zSet.rangeWithScores(key,start,end);
        return ret;
    &#125;

    /**
     * 有序集合添加
     * @param key
     * @param value
     */
    public Double zSetScore(String key, Object value) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        return zSet.score(key,value);
    &#125;


    /**
     * 有序集合添加分数
     * @param key
     * @param value
     * @param scoure
     */
    public void incrementScore(String key, Object value, double scoure) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        zSet.incrementScore(key, value, scoure);
    &#125;


    /**
     * 有序集合获取排名
     * @param key
     */
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; reverseZSetRankWithScore(String key, long start,long end) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; ret = zSet.reverseRangeByScoreWithScores(key,start,end);
        return ret;
    &#125;

    /**
     * 有序集合获取排名
     * @param key
     */
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; reverseZSetRankWithRank(String key, long start, long end) &#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; ret = zSet.reverseRangeWithScores(key, start, end);
        return ret;
    &#125;

    /**
     * 有序集合获取一定范围的数据
     * @param key
     * @param offset
     * @param limit
     * @return
     */
    public &lt;T&gt; Set&lt;T&gt; reverseRange(Class&lt;T&gt; tClass,String key,int offset,int limit)&#123;
        ZSetOperations&lt;String, Object&gt; zSet = redisTemplate.opsForZSet();
        Set&lt;T&gt; sets = (Set&lt;T&gt;) zSet.reverseRange(key, offset, limit);
        return sets;
    &#125;

&#125;
</code></pre>
<h3 id="5-ResultVoUtil"><a href="#5-ResultVoUtil" class="headerlink" title="5.ResultVoUtil"></a>5.ResultVoUtil</h3><p><strong>主要代码</strong></p>
<pre><code class="java">public class ResultVoUtil &#123;

    /**
     * 请求失败的结果对象封装方法
     * @param t
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; ResultVo error(T t)&#123;
        return ResultVo.error(((ResultEnum) t).getMsg());
    &#125;

    /**
     * 请求成功结果对象的封装方法
     * @param t
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; ResultVo success(T t)&#123;
        return ResultVo.success(((ResultEnum) t).getMsg());
    &#125;
&#125;
</code></pre>
<h3 id="6-ThreadLocalHolder"><a href="#6-ThreadLocalHolder" class="headerlink" title="6.ThreadLocalHolder"></a>6.ThreadLocalHolder</h3><p><strong>主要代码</strong></p>
<pre><code class="java">@Component
public class ThreadLocalHolder&lt;T&gt; &#123;
    private ThreadLocal&lt;T&gt; cache = new ThreadLocal&lt;&gt;();

    /**
     * 设置缓存数据
     * @param t
     */
    public void setCache(T t)&#123;
        cache.set(t);
    &#125;

    /**
     * 获取缓存数据
     * @return
     */
    public T getCache()&#123;
        return cache.get();
    &#125;

    /**
     * 清除缓存
     */
    public void clear()&#123;
        cache.remove();
    &#125;
&#125;
</code></pre>
<h2 id="8-配置类"><a href="#8-配置类" class="headerlink" title="8.配置类"></a>8.配置类</h2><h3 id="1-KaptchaConfig"><a href="#1-KaptchaConfig" class="headerlink" title="1.KaptchaConfig"></a>1.KaptchaConfig</h3><p>主要用于配置 kaptcha（图片验证码）的生成器。</p>
<p>首先，在该配置类中定义了一个名为 kaptchaProducer 的 Bean，返回类型为 Producer。通过 @Bean 注解进行标注，表示该方法会被 Spring 容器托管，可以在其它组件中直接注入使用。</p>
<p>然后，该方法中创建了一个 Properties 对象，并将一些属性设置到其中，如验证码图片的宽度、高度、字体大小、字符集等。这些属性的含义如下：</p>
<ul>
<li>kaptcha.image.width：验证码图片宽度</li>
<li>kaptcha.image.height：验证码图片高度</li>
<li>kaptcha.textproducer.font.size：验证码字体大小</li>
<li>kaptcha.textproducer.font.color：验证码字体颜色</li>
<li>kaptcha.textproducer.char.string：验证码字符集</li>
<li>kaptcha.textproducer.char.length：验证码字符长度</li>
<li>kaptcha.noise.impl：验证码干扰器实现类</li>
</ul>
<p>最后，通过 DefaultKaptcha 类创建一个默认的 kaptcha 实例，并通过 Config 类将设置的属性注入到实例中，最终将该实例作为 Bean 返回。</p>
<pre><code class="java">@Configuration
public class KaptchaConfig &#123;

    @Bean
    public Producer kaptchaProducer()&#123;
        Properties properties = new Properties();
        properties.setProperty(&quot;kaptcha.image.width&quot;,&quot;100&quot;);
        properties.setProperty(&quot;kaptcha.image.height&quot;,&quot;40&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;,&quot;32&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;,&quot;0,0,0&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;,&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;,&quot;4&quot;);
        properties.setProperty(&quot;kaptcha.noise.impl&quot;,&quot;com.google.code.kaptcha.impl.NoNoise&quot;);


        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        Config config = new Config(properties);
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    &#125;

&#125;
</code></pre>
<h3 id="2-MailClientConfig"><a href="#2-MailClientConfig" class="headerlink" title="2.MailClientConfig"></a>2.MailClientConfig</h3><pre><code>@Component
@Slf4j
public class MailClientConfig &#123;

    @Autowired
    private JavaMailSender mailSender;

    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)
    private String from;

    /**
     * 发送邮件方法
     * @param to
     * @param subject
     * @param content
     */
    @Async(value = &quot;taskExecutor&quot;)
    public void sendMail(String to,String subject,String content)&#123;
        try &#123;
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content,true);
            mailSender.send(helper.getMimeMessage());
        &#125; catch (MessagingException e) &#123;
            log.error(&quot;发送邮件失败:&quot;+e.getMessage());
        &#125;
    &#125;

&#125;
</code></pre>
<h3 id="2-QuartzConfig"><a href="#2-QuartzConfig" class="headerlink" title="2.QuartzConfig"></a>2.QuartzConfig</h3><pre><code class="java">@Configuration
public class QuartzConfig &#123;

    /**
     * FactoryBean简化bean的实例化过程:
     *      spring通过FactoryBean封装Bean的实例化过程。
     *      FactoryBean装配到spring容器中。
     *      将FactoryBean注入给其他bean。
     *      该bean得到的是FactoryBean所管理的对象实例.
     *
     */

    /**
     * 配置JobDetail:初始化JobDetailFactoryBean，实现简化JobDetail实例化过程
     * @return
     */
    @Bean
    public JobDetailFactoryBean discussPostScoreRefreshJobDetailFactoryBean()&#123;
        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
        factoryBean.setJobClass(DiscussPostScoreRefreshJob.class);
        factoryBean.setName(&quot;DiscussPostScoreRefreshJob&quot;);
        factoryBean.setGroup(&quot;DiscussPostScoreRefreshJobGroup&quot;);
        // 任务是否长久保存
        factoryBean.setDurability(true);
        // 任务是否可恢复
        factoryBean.setRequestsRecovery(true);
        return factoryBean;
    &#125;

    /**
     * 配置Trigger(SimpleTriggerFactoryBean,CronTriggerFactoryBean)
     *      SimpleTriggerFactoryBean：简单触发器工厂bean 触发方式：每隔多少时间做一次任务
     *      CronTriggerFactoryBean:复杂~,使用cron表达式执行定时任务：在某个特定时间点执行任务
     * @param discussPostScoreRefreshJobDetailFactoryBean
     * @return
     */
    @Bean
    public SimpleTriggerFactoryBean getDiscussPostScoreRefreshTriggerFactoryBean(JobDetail discussPostScoreRefreshJobDetailFactoryBean)&#123;
        SimpleTriggerFactoryBean discussPostScoreRefreshTriggerFactoryBean = new SimpleTriggerFactoryBean();
        discussPostScoreRefreshTriggerFactoryBean.setJobDetail(discussPostScoreRefreshJobDetailFactoryBean);
        discussPostScoreRefreshTriggerFactoryBean.setName(&quot;DiscussPostScoreRefreshTrigger&quot;);
        // 执行频率
        discussPostScoreRefreshTriggerFactoryBean.setRepeatInterval(1000 * 60 * 5);
        discussPostScoreRefreshTriggerFactoryBean.setGroup(&quot;DiscussPostScoreRefreshTriggerGroup&quot;);
        // JobDataMap存储job的状态
        discussPostScoreRefreshTriggerFactoryBean.setJobDataMap(new JobDataMap());

        return discussPostScoreRefreshTriggerFactoryBean;
    &#125;
&#125;
</code></pre>
<p>Spring Security 配置类，包含了多个安全配置方法。</p>
<p><code>configure(WebSecurity web)</code> 方法用于配置忽略某些静态资源的拦截，这里通过 <code>ignoring()</code> 方法配置了 <code>/resources/**</code> 下的静态资源不需要被拦截。</p>
<p><code>configure(HttpSecurity http)</code> 方法用于配置权限控制和异常处理。其中，<code>authorizeRequests()</code> 方法用于配置 URL 的权限控制，例如 <code>/user/settings</code> 需要具有 <code>ADMIN</code>、<code>USER</code> 或者 <code>MODERATOR</code> 任意一种权限，<code>/discuss/top</code> 则需要具有 <code>MODERATOR</code> 权限，其余 URL 则无限制。<code>csrf()</code> 方法用于禁用 CSRF 攻击防御机制。</p>
<p>异常处理方面，<code>authenticationEntryPoint()</code> 方法配置了未登录时的异常处理逻辑，包括判断请求是否为 AJAX 请求，并返回对应的 JSON 数据或者重定向到登录页面；<code>accessDeniedHandler()</code> 方法配置了权限不足时的异常处理逻辑，同样包括判断请求是否为 AJAX 请求，并返回对应的 JSON 数据或者重定向到权限不足页面。</p>
<p>最后，<code>logout()</code> 方法用于配置退出登录相关的路径和逻辑，这里将默认的 <code>/logout</code> 路径修改为 <code>/security-logout</code>，以便后续自定义退出登录逻辑的实现。</p>
<h3 id="3-RedisConfig"><a href="#3-RedisConfig" class="headerlink" title="3.RedisConfig"></a>3.RedisConfig</h3><pre><code class="java">@Configuration
public class RedisConfig &#123;

    @Bean
    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123;
        RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(factory);
        // 设置key的序列化方式
        template.setKeySerializer(RedisSerializer.string());

        // 设置value的序列化方式
        template.setValueSerializer(RedisSerializer.json());

        // 设置hash的key的序列化方式
        template.setHashKeySerializer(RedisSerializer.string());

        // 设置hash的value的序列化方式
        template.setHashValueSerializer(RedisSerializer.json());

        // 设置参数生效
        template.afterPropertiesSet();

        return template;
    &#125;
&#125;
</code></pre>
<h3 id="4-SecurityConfig"><a href="#4-SecurityConfig" class="headerlink" title="4.SecurityConfig"></a>4.SecurityConfig</h3><p>Spring Security 的配置类，主要包括了对用户权限的控制和异常处理等方面的配置。</p>
<p>在 configure(WebSecurity web) 方法中忽略了对静态资源的拦截，即 “&#x2F;resources&#x2F;**” 下的静态资源直接访问，不做拦截。</p>
<p>在 configure(HttpSecurity http) 方法中设置了请求的授权规则，允许哪些权限的用户访问哪些资源。默认开启了 CSRF 防御，使用了禁用 CSRF 防御的配置。同时也设置了异常处理：当用户访问某个资源时，若没有权限，会返回 403 状态码的错误信息或者重定向到登录页面。</p>
<p>另外，还通过覆盖 security 默认的逻辑，实现了退出拦截的修改，具体来说就是将 logout 拦截路径修改为其他路径。</p>
<p>最后，还加入了一个 httpFirewall() 方法，用于配置允许不规范 URL 访问，解决头像显示 URL 不规范的问题。</p>
<pre><code class="java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;

    public static final String XML_HTTP_REQUEST = &quot;XMLHttpRequest&quot;;

    @Override
    public void configure(WebSecurity web) throws Exception &#123;
        // 忽略对静态资源的拦截 /resources/下静态资源都是直接访问，不用拦截
        web.ignoring().antMatchers(&quot;/resources/**&quot;);
    &#125;

    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        // 授权
        http.authorizeRequests()
                // 登录之后，如果含有有效的用户身份，这以下权限登录之后军具有
                .antMatchers(
                &quot;/user/settings&quot;,
                        &quot;/user/upload&quot;,
                        &quot;/user/updatePassword&quot;,
                        &quot;/user/mypost&quot;,
                        &quot;/user/myreply&quot;,
                        &quot;/discuss/add/&quot;,
                        &quot;/comment/add/**&quot;,
                        &quot;/message/**&quot;,
                        &quot;/like/**&quot;,
                        &quot;/follow/**&quot;
        ).hasAnyAuthority(SystemConstant.AUTHORITY_ADMIN,
                SystemConstant.AUTHORITY_USER,
                SystemConstant.AUTHORITY_MODERATOR
        ).antMatchers(
                &quot;/disucss/top&quot;,
                &quot;/discuss/fine&quot;
        ).hasAnyAuthority(
                SystemConstant.AUTHORITY_MODERATOR
        ).antMatchers(
                &quot;/discuss/delete&quot;,
                &quot;/data/**&quot;,
                &quot;/*.html&quot;,
                &quot;/database&quot;
        ).hasAnyAuthority(
                SystemConstant.AUTHORITY_ADMIN
        ).anyRequest().permitAll()
        // 默认引入spring security之后，csrf防御是默认开启的,使用此配置禁用csrf攻击防御
         .and().csrf().disable();

        // 权限不够时的异常处理
        http.exceptionHandling()
                .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;
                    // 未登录时的处理
            @Override
            public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;
                String xRequestWith = request.getHeader(&quot;x-requested-with&quot;);
                if (XML_HTTP_REQUEST.equals(xRequestWith))&#123;
                    response.setContentType(&quot;application/plain;charset=utf-8&quot;);
                    PrintWriter writer = response.getWriter();
                    writer.write(CommonUtil.getJsonString(403,&quot;你还没有登录哦！&quot;));
                &#125;else&#123;
                    response.sendRedirect(request.getContextPath()+&quot;/user/loginPage&quot;);
                &#125;
            &#125;
        &#125;).accessDeniedHandler(new AccessDeniedHandler() &#123;
            // 权限不足的处理
                    @Override
                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;
                        String xRequestWith = request.getHeader(&quot;x-requested-with&quot;);
                        if (XML_HTTP_REQUEST.equals(xRequestWith))&#123;
                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);
                            PrintWriter writer = response.getWriter();
                            writer.write(CommonUtil.getJsonString(403,&quot;你没有访问此功能的权限&quot;));
                        &#125;else&#123;
                            response.sendRedirect(request.getContextPath()+&quot;/denied&quot;);
                        &#125;
                    &#125;
                &#125;);

        // security底层默认会拦截/logout请求，进行退出处理，所以覆盖默认的逻辑，才能执行我们自己的推出代码
        // logout拦截路径修改为其他路径,这样就绕过了security的退出拦截
        http.logout().logoutUrl(&quot;/security-logout&quot;);
    &#125;

    /**
     * 此配置允许不规范 URL 访问：解决头像显示url不规范问题
     * @return
     */
    @Bean
    public HttpFirewall httpFirewall() &#123;
        return new DefaultHttpFirewall();
    &#125;
&#125;
</code></pre>
<p><strong>要点</strong></p>
<blockquote>
<p>​    &#x2F;&#x2F; 权限不够时的异常处理<br>​    http.exceptionHandling()<br>​            .authenticationEntryPoint(new AuthenticationEntryPoint() {<br>​                &#x2F;&#x2F; 未登录时的处理<br>​        @Override<br>​        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {<br>​            String xRequestWith &#x3D; request.getHeader(“x-requested-with”);<br>​            if (XML_HTTP_REQUEST.equals(xRequestWith)){<br>​                response.setContentType(“application&#x2F;plain;charset&#x3D;utf-8”);<br>​                PrintWriter writer &#x3D; response.getWriter();<br>​                writer.write(CommonUtil.getJsonString(403,”你还没有登录哦！”));<br>​            }else{<br>​                response.sendRedirect(request.getContextPath()+”&#x2F;user&#x2F;loginPage”);<br>​            }<br>​        }<br>​    }).accessDeniedHandler(new AccessDeniedHandler() {<br>​        &#x2F;&#x2F; 权限不足的处理<br>​                @Override<br>​                public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {<br>​                    String xRequestWith &#x3D; request.getHeader(“x-requested-with”);<br>​                    if (XML_HTTP_REQUEST.equals(xRequestWith)){<br>​                        response.setContentType(“application&#x2F;plain;charset&#x3D;utf-8”);<br>​                        PrintWriter writer &#x3D; response.getWriter();<br>​                        writer.write(CommonUtil.getJsonString(403,”你没有访问此功能的权限”));<br>​                    }else{<br>​                        response.sendRedirect(request.getContextPath()+”&#x2F;denied”);<br>​                    }<br>​                }<br>​            });</p>
<p>​    &#x2F;&#x2F; security底层默认会拦截&#x2F;logout请求，进行退出处理，所以覆盖默认的逻辑，才能执行我们自己的推出代码<br>​    &#x2F;&#x2F; logout拦截路径修改为其他路径,这样就绕过了security的退出拦截<br>​    http.logout().logoutUrl(“&#x2F;security-logout”);<br>}</p>
</blockquote>
<p>这段代码实现了 Spring Security 的异常处理，包括未登录时的处理和权限不足的处理。</p>
<p>未登录时的处理是由 AuthenticationEntryPoint 完成的，当用户访问需要登录才能访问的资源时，如果用户尚未登录，会抛出未认证的异常。在未登录时的处理中，通过判断请求头中是否包含 “x-requested-with” 来判断请求类型，若为 AJAX 请求，则返回 JSON 格式的错误信息；否则，重定向到指定的登录页面。</p>
<p>权限不足的处理是由 AccessDeniedHandler 完成的，当用户没有相应的访问权限时，会抛出无权访问的异常。在权限不足的处理中，同样通过判断请求头中是否包含 “x-requested-with” 来判断请求类型，若为 AJAX 请求，则返回 JSON 格式的错误信息；否则，重定向到指定的无权访问页面。</p>
<p>此外，因为 Spring Security 底层默认会拦截 “&#x2F;logout” 请求，进行退出处理，所以还需要覆盖默认的逻辑，将 “&#x2F;logout” 拦截路径修改为其他路径，这样才能执行我们自己的退出代码。具体来说，使用 http.logout().logoutUrl() 方法，将 “&#x2F;logout” 修改为 “&#x2F;security-logout”，从而避免了 Spring Security 的退出拦截。</p>
<h3 id="5-Swagger2Config"><a href="#5-Swagger2Config" class="headerlink" title="5.Swagger2Config"></a>5.Swagger2Config</h3><pre><code class="java">@Configuration
@EnableSwagger2
public class Swagger2Config &#123;

    /**
     * @Description 装配Swagger的Docket对象,配置Swagger基础信息
     * @param
     * @return  Docket对象
     * @throws
     */
    @Bean
    public Docket createRestApi() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.nowcoder.community&quot;))
                .paths(PathSelectors.any())
                .build();
    &#125;

    /**
     * @Description 配置接口信息，返回Swagger接口对象
     * @param
     * @return  ApiInfo对象
     * @throws
     */
    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;Spring Boot中使用Swagger2构建Restful APIs&quot;)
                .description(&quot;社区论坛&quot;)
                .termsOfServiceUrl(&quot;http://www.nowcoder.com/community&quot;)
                .contact(new Contact(&quot;nowcoder&quot;,&quot;http://www.nowcoder.com/&quot;,&quot;32912299355@qq.com&quot;))
                .version(&quot;1.0.0&quot;)
                .license(&quot;信息科技有限公司&quot;)
                .build();

    &#125;
&#125;
</code></pre>
<h3 id="6-ThreadPoolConfig"><a href="#6-ThreadPoolConfig" class="headerlink" title="6.ThreadPoolConfig"></a>6.ThreadPoolConfig</h3><pre><code class="java">@Configuration
@EnableScheduling
@EnableAsync
public class ThreadPoolConfig &#123;
    /**
     * 每秒需要多少个线程处理?
     * tasks/(1/taskcost)
     */
    private int corePoolSize = 3;

    /**
     * 线程池维护线程的最大数量
     * (max(tasks)- queueCapacity)/(1/taskcost)
     */
    private int maxPoolSize = 3;

    /**
     * 缓存队列
     * (coreSizePool/taskcost)*responsetime
     */
    private int queueCapacity = 10;

    /**
     * 允许的空闲时间
     * 默认为60
     */
    private int keepAlive = 100;

    @Bean
    public TaskExecutor taskExecutor() &#123;
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 设置核心线程数
        executor.setCorePoolSize(corePoolSize);
        // 设置最大线程数
        executor.setMaxPoolSize(maxPoolSize);
        // 设置队列容量
        executor.setQueueCapacity(queueCapacity);
        // 设置允许的空闲时间（秒）
        //executor.setKeepAliveSeconds(keepAlive);
        // 设置默认线程名称
        executor.setThreadNamePrefix(&quot;thread-&quot;);
        // 设置拒绝策略rejection-policy：当pool已经达到max size的时候，如何处理新任务
        // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // 等待所有任务结束后再关闭线程池
        executor.setWaitForTasksToCompleteOnShutdown(true);
        return executor;
    &#125;
&#125;
</code></pre>
<h3 id="7-WebMvcConfig"><a href="#7-WebMvcConfig" class="headerlink" title="7.WebMvcConfig"></a>7.WebMvcConfig</h3><pre><code class="java">@Configuration
public class WebMvcConfig implements WebMvcConfigurer &#123;


    @Autowired
    private MessageInterceptor messageInterceptor;

    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;

    @Autowired
    private DataInterceptor dataInterceptor;

    /**
     * 配置登录拦截器
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;


        registry.addInterceptor(messageInterceptor)
                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;, &quot;/**/*.ico&quot;, &quot;/loginPage&quot;, &quot;/registerPage&quot;);

        registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;, &quot;/**/*.ico&quot;, &quot;/loginPage&quot;, &quot;/registerPage&quot;);

        registry.addInterceptor(dataInterceptor)
                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;, &quot;/**/*.ico&quot;, &quot;/loginPage&quot;, &quot;/registerPage&quot;);
    &#125;

    /**
     * 跨域配置
     * @return
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() &#123;
        return new WebMvcConfigurer() &#123;
            @Override
            public void addCorsMappings(CorsRegistry registry) &#123;
                registry.addMapping(&quot;/**&quot;).allowedMethods(&quot;*&quot;);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<h3 id="8-WkConfig"><a href="#8-WkConfig" class="headerlink" title="8.WkConfig"></a>8.WkConfig</h3><pre><code class="java">@Configuration
@Slf4j
public class WkConfig &#123;

    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)
    private String wkImageStorage;

    @PostConstruct
    public void init()&#123;
        // 创建wk图片目录
        File file = new File(wkImageStorage);

        if (!file.exists()) &#123;
            file.mkdirs();
            log.info(&quot;创建wk图片目录:&quot;+wkImageStorage);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="9-DatabaseEndPoint"><a href="#9-DatabaseEndPoint" class="headerlink" title="9.DatabaseEndPoint"></a>9.DatabaseEndPoint</h3><p>pring Boot Actuator 的端点（Endpoint）类，用于检测数据库连接是否正常。</p>
<p>具体来说，该类被注解为 @Component，表示它是一个 Spring 组件，会被自动扫描并纳入 Spring 容器管理。同时，它还被注解为 @Endpoint，并设置了 id 为 “database”，表示它是一个 Actuator 端点，通过 “&#x2F;actuator&#x2F;database” 访问可以触发对应的接口方法。</p>
<p>该类中定义了一个名为 checkConnection 的方法，使用了 @ReadOperation 注解，表示该方法用于处理 GET 请求并返回响应数据。在该方法中，使用了 @Autowired 注解将 DataSource 数据源对象注入到实例变量中，然后尝试获取一个数据库连接并返回检测结果。</p>
<p>如果连接成功，则返回操作码为 0、提示信息为 “获取连接成功！” 的 JSON 字符串；否则返回操作码为 1、提示信息为 “获取连接失败” 的 JSON 字符串，并记录日志。</p>
<pre><code class="java">@Component
@Endpoint(id = &quot;database&quot;)
@Slf4j
@SuppressWarnings(&quot;all&quot;)
public class DatabaseEndPoint &#123;
    @Autowired
    private DataSource dataSource;

    @ReadOperation
    public String checkConnection()&#123;
        try (Connection connection = dataSource.getConnection();)&#123;
            return CommonUtil.getJsonString(0,&quot;获取连接成功！&quot;);
        &#125; catch (SQLException e) &#123;
            log.error(&quot;获取连接失败:&quot;+e.getMessage());
            return CommonUtil.getJsonString(1,&quot;获取连接失败&quot;);
        &#125;
    &#125;

    
&#125;
</code></pre>
<h3 id="10-EventConsumer"><a href="#10-EventConsumer" class="headerlink" title="10.EventConsumer"></a>10.EventConsumer</h3><p>基于Spring Boot框架的事件消费者类，用于消费Kafka消息队列中的事件消息。该类主要包含以下方法：</p>
<ol>
<li>handleCommentMessage用于处理评论事件、点赞事件以及关注事件，并向指定用户发送站内通知。</li>
<li>handlePublishEvent用于监听发帖事件，将对应的DiscussPost对象保存至Elasticsearch搜索引擎。</li>
<li>handleDeleteEvent用于监听删除帖子事件，将该帖子从Elasticsearch搜索引擎中删除。</li>
<li>handleShareMessage用于处理分享事件，调用wkhtmltopdf生成对应的长图，并上传至七牛云存储。</li>
</ol>
<p>其中，handleShareMessage方法中使用了定时任务的方式监视图片是否生成，并在图片生成后上传至七牛云存储。在这里使用taskScheduler线程池任务定时器，因为消费者消费事件具有抢占机制，一台服务器启用定时器和其他服务器没有影响，所以不用分布式定时任务框架quartz。</p>
<pre><code class="java">@Component
@Slf4j
public class EventConsumer implements MessageConstant &#123;

    @Autowired
    private MessageService messageService;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private ElasticsearchService elasticsearchService;

    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)
    private String wkImageStorage;

    @Value(&quot;$&#123;wk.image.command&#125;&quot;)
    private String wkCommand;

    @Value(&quot;$&#123;qiniu.key.access&#125;&quot;)
    private String accessKey;

    @Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)
    private String secretKey;

    @Value(&quot;$&#123;qiniu.bucket.share.name&#125;&quot;)
    private String shareBucketName;

    @Autowired
    private ThreadPoolTaskScheduler taskScheduler;

    public final String JSON_DATA_KEY = &quot;code&quot;;
    public final String JSON_DATA_VALUE = &quot;0&quot;;


    /**
     * 一个方法可以消费kafka多个topic，一个topic可以被多个方法消费
     * @param record
     */
    @KafkaListener(topics = &#123;TOPIC_FOLLOW,TOPIC_COMMENT,TOPIC_LIKE&#125;)
    public void handleCommentMessage(ConsumerRecord record)&#123;
        Event event = JSONObject.parseObject(record.value().toString(), Event.class);
        if(!checkRecord(record,event))&#123;
            return;
        &#125;

        // 发送站内通知
        Message message = new Message();
        message.setFromId(SystemConstant.SYSTEM_USER_ID);
        message.setToId(event.getEntityUserId());
        message.setConversationId(event.getTopic());
        message.setCreateTime(new Date());
        message.setStatus(0);

        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(16);
        map.put(&quot;userId&quot;,event.getUserId());
        map.put(&quot;entityType&quot;,event.getEntityType());
        map.put(&quot;entityId&quot;,event.getEntityId());
        if (!event.getData().isEmpty()) &#123;
            for (Map.Entry&lt;String,Object&gt; entry:event.getData().entrySet()) &#123;
                map.put(entry.getKey(),entry.getValue());
            &#125;
        &#125;
        message.setContent(JSONObject.toJSONString(map));
        messageService.addMessage(message);
    &#125;

    /**
     * 监听发帖事件
     * @param record
     */
    @KafkaListener(topics = &#123;MessageConstant.TOPIC_PUBLISH&#125;)
    public void handlePublishEvent(ConsumerRecord record)&#123;
        Event event = JSONObject.parseObject(record.value().toString(), Event.class);
        if(!checkRecord(record,event))&#123;
            return;
        &#125;

        DiscussPost discussPost = discussPostService.findDiscussPostById(event.getEntityId());
        elasticsearchService.saveDiscussPost(discussPost);
    &#125;

    @KafkaListener(topics = &#123;MessageConstant.TOPIC_DELETE&#125;)
    public void handleDeleteEvent(ConsumerRecord record)&#123;
        Event event = JSONObject.parseObject(record.value().toString(), Event.class);
        if(!checkRecord(record,event))&#123;
            return;
        &#125;
        elasticsearchService.deleteDiscusspost(event.getEntityId());
    &#125;

    private boolean checkRecord(ConsumerRecord record,Event event)&#123;
        if(CommonUtil.isEmtpy(record) || CommonUtil.isEmtpy(record.value()))&#123;
            log.error(&quot;消息内容为空.&quot;);
            return false;
        &#125;

        if(CommonUtil.isEmtpy(event))&#123;
            log.error(&quot;消息格式错误&quot;);
            return false;
        &#125;
        return true;
    &#125;

    @KafkaListener(topics = TOPIC_SHARE)
    public void handleShareMessage(ConsumerRecord record)&#123;
        Event event = JSONObject.parseObject(record.value().toString(), Event.class);
        if(!checkRecord(record,event))&#123;
            return;
        &#125;

        String htmlUrl = (String) event.getData().get(&quot;htmlUrl&quot;);
        String fileName = (String) event.getData().get(&quot;fileName&quot;);
        String suffix = (String) event.getData().get(&quot;suffix&quot;);

        // 拼接cmd命令
        String cmd = wkCommand + &quot;--quality 75 &quot; +
                htmlUrl + &quot; &quot; + wkImageStorage + &quot;/&quot; + fileName + suffix;

        // 执行命令生成长图
        try &#123;
            Runtime.getRuntime().exec(cmd);
            // 这句话比Runtime.getRuntime().exec(cmd)先执行，所以需要阻塞线程taskScheduler
            log.info(&quot;生成长图成功:&quot; + cmd);
        &#125; catch (IOException e) &#123;
            log.error(&quot;生成长图失败：&#123;&#125;&quot;,e.getMessage());
        &#125;

        // 消费分享事件

        // 启用定时器，监视图片是否生成，如果图片已生成，则上传至七牛云
        /**
         * 在这里使用taskScheduler，因为，消费者消费事件具有抢占机制，
         * 一个事件只有一台机器的消费者消费，一台服务器启用定时器和其他服务器没有影响
         * 所以不用分布式定时任务框架quartz,而使用taskScheduler线程池任务定时器
          */
        UploadTask uploadTask = new UploadTask(fileName,suffix);
        /**
         * Future 封装定时任务的状态，可以停止定时器
         */
        Future scheduledFuture = taskScheduler.scheduleAtFixedRate(uploadTask, 500);
        uploadTask.setFuture(scheduledFuture);
    &#125;

    class UploadTask implements Runnable &#123;

        /**
         * 文件名称
         */
        private String fileName;

        /**
         * 文件后缀
         */
        private String suffix;

        /**
         * 启动任务的返回值，用于停止定时器
         */
        private Future future;

        /**
         * 开始上传时间
         */
        private long startTime;

        /**
         * 上传次数
         */
        private int uploadTimes;

        public void setFuture(Future future) &#123;
            this.future = future;
        &#125;

        public UploadTask(String fileName, String suffix) &#123;
            this.fileName = fileName;
            this.suffix = suffix;
            this.startTime = System.currentTimeMillis();
        &#125;

        @Override
        public void run() &#123;
            // 极端情况，强制关闭定时器
            // 生成图片失败
            if (System.currentTimeMillis() - startTime &gt; SystemConstant.UPLOAD_MILLISECONDS) &#123;
                log.error(&quot;执行时间过程，终止任务:&quot;+ fileName);
                future.cancel(true);
                return;
            &#125;

            // 上传七牛云失败
            if (uploadTimes &gt;= SystemConstant.UPLOAD_TIMES) &#123;
                log.error(&quot;上传次数过多,终止任务：&quot;+ fileName);
                future.cancel(true);
                return;
            &#125;

            String path = wkImageStorage + &quot;/&quot; + fileName + suffix;
            File file = new File(path);

            if (file.exists()) &#123;
                log.info(String .format(&quot;开始第%d次上传[%s].&quot;,++uploadTimes,fileName));
                // 设置响应信息
                StringMap policy = new StringMap();
                policy.put(&quot;returnBody&quot;,CommonUtil.getJsonString(0));

                // 生成上传凭证
                Auth auth = Auth.create(accessKey,secretKey);
                String uploadToken = auth.uploadToken(shareBucketName, fileName, 3600, policy);

                // 指定上传的七牛云机房 : 华北机房
                UploadManager manager = new UploadManager(new Configuration(Zone.zone1()));

                try &#123;
                    // 上传文件到七牛云
                    // 开始上传图片
                    Response response = manager.put(path, fileName, uploadToken, null, &quot;images/&quot; + suffix, false);
                    // 处理响应结果
                    JSONObject jsonData = JSONObject.parseObject(response.bodyString());



                    if (CommonUtil.isEmtpy(jsonData) || jsonData.get(JSON_DATA_KEY)==null||!JSON_DATA_VALUE.equals(jsonData.get(JSON_DATA_KEY))) &#123;
                        log.info(String.format(&quot;第%d次上传失败[%s].&quot;,uploadTimes,fileName));
                    &#125;else&#123;
                        log.info(String.format(&quot;第%d次上传成功[%s].&quot;,uploadTimes,fileName));
                        future.cancel(true);
                    &#125;
                &#125;catch (QiniuException e) &#123;
                    log.info(String.format(&quot;第%d次上传失败[%d].&quot;,uploadTimes,fileName));
                    log.error(&quot;文件上传失败:&#123;&#125;&quot;,e.getMessage());
                &#125;
            &#125;else &#123;
                log.info(&quot;等待图片生成[&quot;+ fileName + &quot;].&quot;);
            &#125;

        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="11-EventProducer"><a href="#11-EventProducer" class="headerlink" title="11.EventProducer"></a>11.EventProducer</h3><p>事件生产者类，用于将事件消息发布到指定的Kafka主题中。该类主要包含handleEvent方法，在该方法中，使用kafkaTemplate将事件转换为JSON字符串，并发布到事件对应的主题。</p>
<pre><code class="java">@Component
public class EventProducer &#123;

    @Autowired
    private KafkaTemplate kafkaTemplate;
    /**
     * 处理事件,发布消息
     * @param event
     */
    public void handleEvent(Event event)&#123;
        // 将事件发布到指定的主题
        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));
    &#125;
&#125;
</code></pre>
<h3 id="12-DiscussPostScoreRefreshJob"><a href="#12-DiscussPostScoreRefreshJob" class="headerlink" title="12.DiscussPostScoreRefreshJob"></a>12.DiscussPostScoreRefreshJob</h3><p>定时任务类，用于更新帖子的分数。主要逻辑为根据帖子的评论数量、点赞数量以及是否加精等因素计算帖子权重，最终得到帖子的分数，并更新帖子分数和同步搜索数据到ES服务器。</p>
<p>该类实现了Quartz框架的Job接口，定义了execute方法，其中注入了RedisTemplate、DiscussPostService、LikeService和ElasticsearchService等相关bean。具体流程如下：</p>
<ol>
<li>获取需要刷新分数的帖子集合。</li>
<li>遍历集合中的每个帖子，计算帖子的分数。</li>
<li>根据计算出的分数更新帖子的分数，并将更新后的数据同步到ES服务器中。</li>
<li>完成所有帖子的分数刷新后，结束任务。</li>
</ol>
<p>该定时任务类中引用了Redis工具类RedisKeyUtil和自定义的ThreadLocalHolder工具类中的一些方法，其中如getPostScoreKey()用于获取Redis中存储帖子分数的key值，findDiscussPostById()用于查询数据库中的帖子信息，updateScore()用于更新帖子的分数，saveDiscussPost()用于将更新后的帖子信息同步到ES服务器中。</p>
<pre><code class="java">/**
 * 热门帖子排行业务
 *  帖子分数刷新计算定时任务
 * @author Alex
 * @version 1.0
 * @company xxx
 * @copyright (c)  xxxInc. All rights reserved.
 * @date 2022/2/21 17:56
 */
@Slf4j
public class DiscussPostScoreRefreshJob implements Job &#123;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private ElasticsearchService elasticsearchService;

    private static final Date EPOCH;

    static &#123;
        try &#123;
            EPOCH = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).parse(&quot;2014-08-01 00:00:00&quot;);
        &#125; catch (ParseException e) &#123;
            throw new RuntimeException(&quot;初始化牛科纪元失败!&quot;,e);
        &#125;
    &#125;

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;
        String postScoreKey = RedisKeyUtil.getPostScoreKey();
        BoundSetOperations operations = redisTemplate.boundSetOps(postScoreKey);
        if (operations.size() == 0) &#123;
            log.info(&quot;[任务取消]:没有要刷新的帖子&quot;);
            return;
        &#125;

        log.info(&quot;[任务开始]:正在刷新帖子分数：&quot;+ operations.size());

        while (operations.size()&gt;0)&#123;
            this.refresh((Integer) operations.pop());
        &#125;

        log.info(&quot;[任务结束]：帖子分数刷新完毕!&quot;);
    &#125;

    /**
     * 刷新单个帖子的分数
     * @param postId
     */
    private void refresh(int postId)&#123;
        DiscussPost discussPost = discussPostService.findDiscussPostById(postId);

        if (CommonUtil.isEmtpy(discussPost))&#123;
            log.error(&quot;该帖子不存在:id=&quot;+ postId);
            return;
        &#125;

        // 是否加精
        boolean isFine = discussPost.getStatus() == 1;

        // 评论数量
        int commentCount = discussPost.getCommentCount();

        // 点赞数量
        long likeCount = likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_POST.getType(), postId);

        // 计算权重
        double w = (isFine?75:0) + commentCount * 10 + likeCount * 2;

        // 分数 = 帖子权重 + 距离天数
        double score = Math.log10(Math.max(w,1)) + (discussPost.getCreateTime().getTime() - EPOCH.getTime()) / (1000 * 3600 * 24);
        // 更新帖子分数
        discussPostService.updateScore(postId,score);

        // 同步搜索数据到es服务器
        discussPost.setScore(score);
        elasticsearchService.saveDiscussPost(discussPost);

    &#125;
&#125;
</code></pre>
<h3 id="13-SimpleJob"><a href="#13-SimpleJob" class="headerlink" title="13.SimpleJob"></a>13.SimpleJob</h3><p>这是一个简单的Quartz Job定时任务类，实现了Quartz框架的Job接口，定义了execute方法。在该方法中，通过SimpleDateFormat类获取当前时间，并输出任务执行的线程名和执行时间。</p>
<p>该类是一个示例定时任务类，适用于简单的定时任务场景，当Quartz框架调度器启动该定时任务后，定时任务会每隔指定时间周期性的执行一次execute方法。在具体项目中，可以根据实际需求编写对应的定时任务类，以完成相应的定时任务操作，如数据备份、定时发送邮件、数据统计等任务。</p>
<pre><code class="java">/**
 * quartz job 定时任务
 * @author Alex
 * @version 1.0
 * @company xxx
 * @copyright (c)  xxxInc. All rights reserved.
 * @date 2022/2/21 16:29
 */
public class SimpleJob implements Job &#123;
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(Thread.currentThread().getName() + &quot;: execute a quartz job at&quot; + simpleDateFormat.format(new Date()));
    &#125;
&#125;
</code></pre>
<h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h2><h3 id="1-已经废弃的登录拦截器"><a href="#1-已经废弃的登录拦截器" class="headerlink" title="1.已经废弃的登录拦截器"></a>1.已经废弃的登录拦截器</h3><pre><code class="java">@Component
@Slf4j
@Deprecated
public class LoginInterceptor implements HandlerInterceptor &#123;

    /**
     * ===============================================
     * preHandle 在controller之前执行
     * postHandle 在controller之后执行
     * afterCompletion 在模板引擎之后执行
     * ===============================================
     */

    @Autowired
    private LoginTicketService loginTicketService;

    @Autowired
    private UserService userService;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    /**
     * @Description
     * @param
     * @return
     * @throws
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        // 获取请求路径
        String uri = request.getRequestURI();
        log.info(&quot;当前请求路径为:&#123;&#125;&quot;,uri);

        // 登录拦截
        if (handler instanceof HandlerMethod) &#123;
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
            // 如果用户未登录，跳转到登录页面
            if(!CommonUtil.isEmtpy(loginRequired)&amp;&amp;CommonUtil.isEmtpy(userThreadLocalHolder.getCache()))&#123;
                response.sendRedirect(request.getContextPath() + &quot;/user/loginPage&quot;);
                log.info(&quot;登录失败,请转向用户登录页面......&quot;);
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    /**
     * @Description
     * @param
     * @return
     * @throws
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        log.info(&quot;postHandle..............&quot;);
        User user = userThreadLocalHolder.getCache();
        if(!CommonUtil.isEmtpy(user))&#123;
            modelAndView.addObject(&quot;loginUser&quot;,user);
        &#125;
    &#125;

    /**
     * @Description
     * @param
     * @return
     * @throws
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        log.info(&quot;afterCompletion..............&quot;);
        // 清除用户信息
        userThreadLocalHolder.clear();
    &#125;
&#125;
</code></pre>
<h3 id="2-自定义异常CustomizeException"><a href="#2-自定义异常CustomizeException" class="headerlink" title="2.自定义异常CustomizeException"></a>2.自定义异常CustomizeException</h3><p>自定义异常类，继承了RuntimeException。该自定义异常类通过构造方法传入状态码、错误信息和方法名称等参数，并提供了getCode()和getMethod()方法，用于获取异常的状态码和出错的方法名称。</p>
<pre><code class="java">public class CustomizeException extends RuntimeException &#123;

    /**
     * 状态码
     */
    private final Integer code;

    /**
     * 方法名称
     */
    private final String method;


    /**
     * 自定义异常
     *
     * @param resultEnum 返回枚举对象
     * @param method     方法
     */
    public CustomizeException(ResultEnum resultEnum, String method) &#123;
        super(resultEnum.getMsg());
        this.code = resultEnum.getCode();
        this.method = method;
    &#125;

    /**
     * @param code    状态码
     * @param message 错误信息
     * @param method  方法
     */
    public CustomizeException(Integer code, String message, String method) &#123;
        super(message);
        this.code = code;
        this.method = method;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public String getMethod() &#123;
        return method;
    &#125;
&#125;
</code></pre>
<h3 id="3-服务层日志切面"><a href="#3-服务层日志切面" class="headerlink" title="3.服务层日志切面"></a>3.服务层日志切面</h3><p>服务层日志切面，使用AOP技术实现。它通过@Aspect注解将其声明为一个切面，并使用@Pointcut指定了切入点，即对com.nowcoder.community.service.*包中的所有方法进行拦截。</p>
<p>在@Before增强方法中，首先获取用户的IP地址和当前时间，然后通过JoinPoint对象获取目标方法的信息，包括方法所在类的名称和方法名称，并将这些信息输出到日志中，以便开发人员或管理员能够及时了解用户访问情况。</p>
<pre><code class="java">/**
 * 服务层日志切面
 *
 * @author Alex
 * @version 1.0
 * @date 2022/2/14 12:11
 */
@Component
@Aspect
@Slf4j
public class ServiceLogAspect &#123;

    @Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)
    public void pointCut() &#123;

    &#125;

    @Before(&quot;pointCut()&quot;)
    public void before(JoinPoint joinPoint) &#123;
        //用户IP地址[1.2.3.4]在&#123;time&#125;,访问了com.nowcoder.community.service.*.*(..)
        //用户IP地址
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (CommonUtil.isEmtpy(requestAttributes)) &#123;
            return;
        &#125;
        HttpServletRequest request = requestAttributes.getRequest();
        String ip = request.getRemoteHost();

        // 获取当前时间
        String now = CommonUtil.getFormatDate(new Date());
        // 目标方法
        String target = joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName();

        log.info(&quot;用户&#123;&#125;,在&#123;&#125;,访问了&#123;&#125;.&quot;, ip, now, target);
    &#125;

&#125;
</code></pre>
<h3 id="4-全局异常处理类"><a href="#4-全局异常处理类" class="headerlink" title="4.全局异常处理类"></a>4.全局异常处理类</h3><p>全局异常处理类，使用@ControllerAdvice注解标记，表示它是一个控制器增强类。它主要用于捕获和处理controller方法中出现的所有异常，并重定向到相应的错误页面或返回JSON格式的错误信息。</p>
<p>在代码中，首先定义了一个常量XML_HTTP_REQUEST，用于判断请求是否为AJAX请求。然后通过@ExceptionHandler注解标记了handleException()方法，表示该方法用于处理所有类型的异常。在方法中，首先将异常信息输出到日志中，然后判断请求是否为AJAX请求，如果是，则返回JSON格式的错误信息；否则，重定向到错误页面。</p>
<p>此外， GlobalExceptionAdvice类中还有一个processCustomizeException()方法，用于处理自定义异常CustomizeException。在方法中，首先将异常信息输出到日志中，然后通过ResultEnum.getByCode()方法获取异常对应的错误信息，并返回ResultVo对象，以便前端进行错误提示或处理。</p>
<pre><code class="java">@ControllerAdvice(annotations = Controller.class)
@Slf4j
public class GlobalExceptionAdvice &#123;

    public static final String XML_HTTP_REQUEST = &quot;XMLHttpRequest&quot;;
    /**
     * 处理controller方法中出现的所有异常，统一记录日志，并且重定向到相应的错误页面
     * @param e
     * @param request
     * @param response
     */
    @ExceptionHandler(&#123;Exception.class&#125;)
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) &#123;
        log.error(&quot;服务器异常:&#123;&#125;&quot;,e.getMessage());
        for (StackTraceElement element : e.getStackTrace())&#123;
            log.error(element.toString());
        &#125;

        String xRequestWith = request.getHeader(&quot;x-requested-with&quot;);
        if(XML_HTTP_REQUEST.equals(xRequestWith))&#123;
            response.setContentType(&quot;application/json;charset=utf-8&quot;);
            PrintWriter writer = null;
            try &#123;
                writer = response.getWriter();
                writer.write(CommonUtil.getJsonString(1,&quot;服务器异常!&quot;));
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125; finally &#123;
                if(writer!=null)&#123;
                    writer.close();
                &#125;
            &#125;
        &#125;else&#123;
            try &#123;
                response.sendRedirect(request.getContextPath()+&quot;/error&quot;);
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;

    /**
     * 自定义异常处理
     */
    @ExceptionHandler(value = CustomizeException.class)
    public ResultVo processCustomizeException(CustomizeException e) &#123;
        log.error(&quot;位置:&#123;&#125; -&gt; 错误信息:&#123;&#125;&quot;, e.getMethod() ,e.getLocalizedMessage());
        return ResultVoUtil.error(Objects.requireNonNull(ResultEnum.getByCode(e.getCode())));
    &#125;
&#125;
</code></pre>
<h3 id="5-敏感词过滤类"><a href="#5-敏感词过滤类" class="headerlink" title="5.敏感词过滤类"></a>5.敏感词过滤类</h3><p>基于Trie树算法实现的敏感词过滤器，主要用于过滤文本中的敏感词。具体来说，这个过程包括如下步骤：</p>
<ol>
<li>初始化前缀树：读取敏感词文件，依次将敏感词添加到前缀树中。</li>
<li>过滤敏感词：遍历待检测的文本，并在前缀树中查找每一个字符对应的节点，直到发现敏感词或者到达文本末尾。在查找过程中，如果出现特殊符号，则跳过。如果当前节点是敏感词的结尾节点，则说明发现了敏感词，需要将该敏感词替换为指定的字符串（本例中为“***”），并继续向后查找。如果当前节点不是敏感词的结尾节点，则继续向后查找。</li>
<li>判断是否为符号：辅助方法，用于判断给定的字符是否为特殊符号。</li>
</ol>
<p>需要注意的点：</p>
<ol>
<li>敏感词文件的格式为一行一个敏感词，如果不符合此格式则会加载失败。</li>
<li>敏感词过滤时，针对一些特殊情况会有额外的处理，例如：敏感词中含有其他特殊符号，或者文本中有多个敏感词重叠的情况。</li>
<li>敏感词过滤结果使用StringBuilder暂存，最后再转换为String类型返回。</li>
</ol>
<pre><code class="java">@Component
@Slf4j
public class SensitiveWordFilter &#123;

    private static final String REPLACEMENT = &quot;***&quot;;

    /**
     * 字典树根节点
     */
    private TrieNode root = new TrieNode();

    /**
     * @Description 初始化前缀树
     * @param
     * @return
     * @throws
     */
    @PostConstruct
    public void init()&#123;
        try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;source/sensitive-word.txt&quot;);
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));
        ) &#123;
            String keyword;
            while ((keyword = bufferedReader.readLine())!=null)&#123;
                this.addKeyWord(keyword);
            &#125;
        &#125; catch (Exception e) &#123;
            log.error(&quot;加载敏感词文件失败:&#123;&#125;&quot;,e.getMessage());
        &#125;

    &#125;

    /**
     * 把敏感词添加到前缀树中
     * @param keyword
     */
    private void addKeyWord(String keyword) &#123;
        TrieNode tempNode = root;
        for (int i = 0; i &lt; keyword.length(); i++) &#123;
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if(subNode==null)&#123;
                // 初始化子节点，挂到当前节点下
                subNode = new TrieNode();
                tempNode.addSubNode(c,subNode);
            &#125;
            // 当前节点指向子节点，进入下一轮循环
            tempNode = subNode;

            // 设置结束标识
            if(i==keyword.length()-1)&#123;
                tempNode.setKeyWordEnd(true);
            &#125;
        &#125;
    &#125;

    /**
     * @Description 过滤敏感词
     * @param text 待过滤的文本
     * @return  过滤后的文本
     * @throws
     */
    public String filterSensitiveWords(String text)&#123;
        if (StringUtils.isBlank(text)) &#123;
            return null;
        &#125;

        // 声明三个指针
        // 指针1
        TrieNode tempNode = root;

        // 指针2
        int begin = 0;

        // 指针3
        int position = 0;

        // StringBuilder 暂存经过敏感词过滤后的文本
        StringBuilder sb = new StringBuilder();
        while (position&lt;text.length())&#123;
            char c = text.charAt(position);
            // 跳过特殊符号
            if(isSymbol(c))&#123;
                // 若指针1处于根节点，将此符号计入结果，让指针2向下走一步
                if(tempNode == root)&#123;
                    sb.append(c);
                    begin++;
                &#125;
                // 无论符号在开头或者中间，指针3都向下走一步
                position++;
                continue;
            &#125;

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if(tempNode == null)&#123;
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 指针1(树形指针)只想root节点
                tempNode = root;
            &#125;else if(tempNode.isKeyWordEnd())&#123;
                // 发现敏感词,将begin~position的字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新执行根节点
                tempNode = root;
            &#125;else&#123;
                // 检查下一个字符
                position++;
            &#125;
        &#125;

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));
        return sb.toString();
    &#125;

    /**
     * @Description 判断是否为符号
     * @param c 传入字符
     * @return  true/false
     * @throws
     */
    private boolean isSymbol(Character c)&#123;
        // 0x2E80~0x9FFF是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF);
    &#125;

    /**
     * 前缀树/字典树 节点定义
     */
    private class TrieNode&#123;
        /**
         * 关键词结束标识：判断是否为敏感词
         */
        private boolean isKeyWordEnd = false;

        /**
         * 当前节点子节点:(key是下级字符,value是下级节点)
         */
        private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;();

        public boolean isKeyWordEnd() &#123;
            return isKeyWordEnd;
        &#125;

        public void setKeyWordEnd(boolean keyWordEnd) &#123;
            isKeyWordEnd = keyWordEnd;
        &#125;

        public Map&lt;Character, TrieNode&gt; getSubNodes() &#123;
            return subNodes;
        &#125;


        public void setSubNodes(Map&lt;Character, TrieNode&gt; subNodes) &#123;
            this.subNodes = subNodes;
        &#125;

        /**
         * 添加子节点
         * @return
         */
        public void addSubNode(Character character,TrieNode trieNode)&#123;
            subNodes.put(character,trieNode);
        &#125;

        /**
         * 根据key获取子节点
         * @param key
         * @return
         */
        public TrieNode getSubNode(Character key)&#123;
            return subNodes.get(key);
        &#125;
    &#125;

&#125;
</code></pre>
<h3 id="6-数据拦截器"><a href="#6-数据拦截器" class="headerlink" title="6.数据拦截器"></a>6.数据拦截器</h3><p>Spring MVC拦截器，用于在请求处理前和请求处理后做一些数据统计工作，主要包括如下几个方面：</p>
<ol>
<li>统计UV：每当有一个请求到达时，在方法preHandle()中获取请求的IP地址，调用dataService.recordUv(ip)方法，记录当前IP访问次数。</li>
<li>统计DAU：对于已经登录的用户，需要在preHandle()方法中通过ThreadLocal获取当前用户信息，并调用dataService.recordDau(user.getId())方法，记录该用户访问次数。</li>
<li>其他：在postHandle()方法和afterCompletion()方法中暂时没有需要处理的逻辑。</li>
</ol>
<p>需要注意的是，在方法preHandle()中，需要首先调用ThreadLocalHolder类（自定义的一个线程安全的ThreadLocal类）的getCache()方法来获取当前用户信息，保证了多线程并发操作时获取的都是各自的用户信息。另外，在这个类中还注入了一个DataService的实例，用于实现对数据的处理及统计。</p>
<pre><code class="java">@Component
public class DataInterceptor implements HandlerInterceptor &#123;
    @Autowired
    private DataService dataService;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 统计UV
        String ip = request.getRemoteHost();
        dataService.recordUv(ip);

        // 统计DAU
        User user = userThreadLocalHolder.getCache();
        if(!CommonUtil.isEmtpy(user))&#123;
            dataService.recordDau(user.getId());
        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<h3 id="7-用户登录权限认证拦截器"><a href="#7-用户登录权限认证拦截器" class="headerlink" title="7.用户登录权限认证拦截器"></a>7.用户登录权限认证拦截器</h3><p>用于检查用户登录状态及权限认证。具体实现如下：</p>
<ol>
<li>在方法preHandle()中，首先根据请求路径获取请求的uri，并调用CookieUtil.getValue(request, “ticket”)方法从cookie中获取用户凭证ticket。</li>
<li>如果ticket不为空，则再调用loginTicketService.findLoginTicket(ticket)方法查询数据库中该凭证是否存在。</li>
<li>如果凭证不存在，则重定向到登录页面，同时记录日志，返回false表示该请求已经被拦截。</li>
<li>如果凭证存在，则检查其有效性，即是否过期或者是否被注销，如果有效则继续进行下一步操作。</li>
<li>继续通过loginTicket.getUserId()方法查询该凭证所对应的用户，并将该用户信息保存在当前线程的ThreadLocal变量中，以便后续使用。</li>
<li>如果用户信息正确，则构建用户认证的结果，并存入SecurityContextImpl中，方便后续security授权使用。最后返回true表示该请求可以被放行。</li>
<li>在方法postHandle()中，从ThreadLocal中获取当前用户信息并将其添加到ModelAndView对象中的loginUser属性中。</li>
<li>在方法afterCompletion()中，清除ThreadLocal中保存的用户信息并清空SecurityContextHolder中的认证信息。</li>
</ol>
<p>总之，在这个拦截器中，可以保证所有需要进行登录认证的请求都会被拦截下来进行处理，并且从数据库和cookie中查询出对应的用户凭证等信息，以保证安全性和可控性。同时，该拦截器也方便后续业务模块以及授权模块的使用。</p>
<pre><code class="java">@Component
@Slf4j
public class LoginTicketInterceptor implements HandlerInterceptor &#123;
    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    @Autowired
    private LoginTicketService loginTicketService;

    @Autowired
    private UserService userService;


    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 获取请求路径
        String uri = request.getRequestURI();
        log.info(&quot;当前请求路径为:&#123;&#125;&quot;,uri);
        // 从cookie中获取凭证
        String ticket = CookieUtil.getValue(request, &quot;ticket&quot;);
        if(!CommonUtil.isEmtpy(ticket))&#123;
            // 查询凭证
            LoginTicket loginTicket = loginTicketService.findLoginTicket(ticket);
            if(CommonUtil.isEmtpy(loginTicket))&#123;
                response.sendRedirect(request.getContextPath() + &quot;/user/loginPage&quot;);
                String remoteHost = request.getRemoteHost();
                log.info(&quot;用户&#123;&#125;未登录,正在转向登录页面......&quot;,remoteHost);
                return false;
            &#125;else&#123;
                // 检查登录凭证是否有效
                if(loginTicket.getStatus()==0&amp;&amp;loginTicket.getExpired().after(new Date()))&#123;
                    // 根据凭证查询用户
                    User user = userService.findUserById(loginTicket.getUserId());
                    // 在本次请求中持有用户信息
                    userThreadLocalHolder.setCache(user);
                    log.info(&quot;&#123;&#125;用户登录成功,当前登录时间为&#123;&#125;&quot;,user.getUsername(),CommonUtil.getFormatDate(new Date()));
                    // 构建用户认证的结果，并存入SecurityContext,便于security授权
                    Authentication authentication = new UsernamePasswordAuthenticationToken(user, user.getPassword(), userService.getAuthorites(user.getId()));
                    SecurityContextHolder.setContext(new SecurityContextImpl(authentication));
                    return true;
                &#125;
            &#125;

        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        log.info(&quot;postHandle..............&quot;);
        User user = userThreadLocalHolder.getCache();
        if(!CommonUtil.isEmtpy(user))&#123;
            modelAndView.addObject(&quot;loginUser&quot;,user);
        &#125;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        log.info(&quot;afterCompletion..............&quot;);
        // 清除用户信息
        userThreadLocalHolder.clear();
        SecurityContextHolder.clearContext();
    &#125;
&#125;
</code></pre>
<h3 id="8-消息拦截器"><a href="#8-消息拦截器" class="headerlink" title="8.消息拦截器"></a>8.消息拦截器</h3><p>Spring MVC拦截器，用于在处理完请求后，在ModelAndView对象中添加用户的未读消息数量。具体实现如下：</p>
<ol>
<li>在方法postHandle()中，首先从ThreadLocal变量中获取当前用户信息，然后判断是否为空。</li>
<li>如果当前用户信息不为空，则调用messageService.findLetterUnreadCount(user.getId(), null)方法查询该用户的未读私信数量；同时调用messageService.findNoticeUnreadCount(user.getId(), null)方法查询该用户的未读系统通知数量。</li>
<li>将私信和系统通知的未读数量累加，将总数保存到ModelAndView对象的allUnreadCount属性中。</li>
<li>如果当前用户信息为空，则不进行任何操作。</li>
<li>在方法afterCompletion()中，为空的实现，不进行任何操作。</li>
</ol>
<p>这个拦截器主要是为了在每次响应完成后，将当前用户的未读消息数量的总和添加到ModelAndView对象中，以便后续业务模块使用。同时，它还依赖于ThreadLocalHolder和MessageService服务类的支持。</p>
<pre><code class="java">@Component
public class MessageInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    @Autowired
    private MessageService messageService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        User user = userThreadLocalHolder.getCache();
        if(!CommonUtil.isEmtpy(user)&amp;&amp;!CommonUtil.isEmtpy(modelAndView))&#123;
            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
            int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);
            modelAndView.addObject(&quot;allUnreadCount&quot;,letterUnreadCount + noticeUnreadCount);
        &#125;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<h2 id="10-主要功能接口：Controller层"><a href="#10-主要功能接口：Controller层" class="headerlink" title="10.主要功能接口：Controller层"></a>10.主要功能接口：Controller层</h2><h3 id="IndexController-java"><a href="#IndexController-java" class="headerlink" title="IndexController.java"></a>IndexController.java</h3><h4 id="需要注入的Bean"><a href="#需要注入的Bean" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">    @Autowired
    private UserService userService;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private FollowService followService;

    @Autowired
    private CommentService commentService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private Producer kaptchaProducer;

    @Autowired
    private RedisTemplate redisTemplate;

    @Value(&quot;$&#123;qiniu.key.access&#125;&quot;)
    private String accessKey;

    @Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)
    private String secretKey;

    @Value(&quot;$&#123;qiniu.bucket.header.name&#125;&quot;)
    private String headerBucketName;

    @Value(&quot;$&#123;qiniu.bucket.header.url&#125;&quot;)
    private String headerBucketUrl;

    @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)
    private String contextPath;

    @Value(&quot;$&#123;community.path.upload&#125;&quot;)
    private String uploadPath;

    @Value(&quot;$&#123;community.path.domain&#125;&quot;)
    private String domain;
</code></pre>
<h4 id="功能1——社区首页"><a href="#功能1——社区首页" class="headerlink" title="功能1——社区首页"></a>功能1——社区首页</h4><ul>
<li>开发流程<ul>
<li>1次请求的执行过程</li>
</ul>
</li>
<li>分步实现<ul>
<li>开发社区首页，显示前10个帖子</li>
<li>开发分页组件，分页显示所有的帖子</li>
</ul>
</li>
</ul>
<p><strong>这里主要讲一下思路</strong></p>
<h5 id="1-分页原理"><a href="#1-分页原理" class="headerlink" title="(1)分页原理"></a>(1)分页原理</h5><p>实现分页需要以下变量：</p>
<ol>
<li>每页显示的记录数（pageSize）：指定每页最多能显示多少条记录。</li>
<li>当前页码（page）：指定当前是第几页。</li>
<li>总记录数（totalCount）：用于计算总页数，即所有记录按照每页显示 pageSize 条来显示，需要分多少页才能展示完。totalCount 应从数据库中查询得到。</li>
</ol>
<p>在分页查询时，我们需要根据以上变量进行计算，得到查询语句中的偏移量和限制记录数，从而获取当前页面所需的数据。具体的计算方式如下：</p>
<ol>
<li>偏移量（offset）计算公式为：offset &#x3D; (page - 1) * pageSize</li>
<li>限制记录数（limit）计算公式为：limit &#x3D; pageSize</li>
</ol>
<p>假设每一页显示 10 条记录，查询第 3 页的数据，需要计算出查询语句中偏移量和限制记录数的值。偏移量计算公式为：<code>offset = (3 - 1) * 10 = 20</code>，即从第 21 条记录开始查询；限制记录数为：<code>limit = 10</code>，即最多查询 10 条记录。这样，就可以在查询语句中使用 limit 和 offset 参数，获取当前页所需要的数据。</p>
<h5 id="2-getIndexPage方法"><a href="#2-getIndexPage方法" class="headerlink" title="(2)getIndexPage方法"></a>(2)getIndexPage方法</h5><p>首页控制器</p>
<pre><code class="java">@RequestMapping(path = &#123;&quot;/index&quot;,&quot;/&quot;&#125;,method = RequestMethod.GET)
public String getIndexPage(Model model, PageInfo pageInfo, @RequestParam(name = &quot;orderMode&quot;,defaultValue = &quot;0&quot;) int orderMode)&#123;
        pageInfo.setRows(discussPostService.findDiscussPostCount(0));
        pageInfo.setPath(&quot;/index?orderMode=&quot;+orderMode);
    
        List&lt;DiscussPost&gt; discussPostList = discussPostService.findDiscussPostList(0, pageInfo.getOffset(), pageInfo.getLimit(),orderMode);
        List&lt;Map&lt;String,Object&gt;&gt; userDiscussPosts = new ArrayList&lt;&gt;();
        if(discussPostList!=null)&#123;
            // 迭代容器装配用户对应的帖子
            for (DiscussPost discussPost : discussPostList) &#123;
                Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(16);
                map.put(&quot;post&quot;,discussPost);
                User user = userService.findUserById(discussPost.getUserId());
                map.put(&quot;user&quot;,user);

                long likeCount = likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_POST.getType(),discussPost.getId());
                map.put(&quot;likeCount&quot;,likeCount);
                userDiscussPosts.add(map);
            &#125;
        &#125;
        model.addAttribute(&quot;discussPosts&quot;,userDiscussPosts);
        model.addAttribute(&quot;orderMode&quot;,orderMode);
        return &quot;/index&quot;;
    &#125;
</code></pre>
<p>从上往下来看，首先看IndexController.java文件，其中的getIndexPage方法实现了此功能。</p>
<p>这个方法有三个参数</p>
<ul>
<li><code>Model model</code>：Spring MVC 框架提供的数据模型对象，用于在请求处理过程中传递数据给视图。</li>
<li><code>PageInfo pageInfo</code>：自定义的分页信息对象，用于封装当前页码、每页数据条数、总数据条数等信息。</li>
<li><code>int orderMode</code>：名为 <code>orderMode</code> 的请求参数，用于指定帖子的排序方式，默认值为 0。</li>
</ul>
<p>其中</p>
<blockquote>
<p>pageInfo.setRows(discussPostService.findDiscussPostCount(0));<br>pageInfo.setPath(“&#x2F;index?orderMode&#x3D;”+orderMode);</p>
</blockquote>
<p><code>pageInfo.setRows(discussPostService.findDiscussPostCount(0));</code> 用来设置分页信息中的总数据条数。具体来说，<code>discussPostService.findDiscussPostCount(0)</code> 是根据参数 0 查询帖子总数，并将其设置到 <code>PageInfo</code> 对象中。总数据条数是分页算法的核心参数之一，通过该参数可以计算出总共有多少页以及各个页面的数据条数等信息。</p>
<p><code>pageInfo.setPath(&quot;/index?orderMode=&quot;+orderMode);</code> 用来设置分页信息中的数据请求路径。具体来说，该路径是在前端生成的分页控件中使用的，用于构造不同页码的数据请求链接。例如，在当前页面为 <code>/index</code>，排序方式为按照赞数从高到低时，下一页的链接地址为 <code>/index?orderMode=1&amp;page=2</code>。</p>
<blockquote>
<p>List<DiscussPost> discussPostList &#x3D; discussPostService.findDiscussPostList(0, pageInfo.getOffset(), pageInfo.getLimit(),orderMode); </p>
<p>List&lt;Map&lt;String,Object&gt;&gt; userDiscussPosts &#x3D; new ArrayList&lt;&gt;();</p>
</blockquote>
<p><code>discussPostService.findDiscussPostList(0, pageInfo.getOffset(), pageInfo.getLimit(),orderMode)</code> 从数据库中查出所有帖子，指定排序方式、偏移量以及每一页数量。</p>
<p><code>List&lt;Map&lt;String,Object&gt;&gt; userDiscussPosts = new ArrayList&lt;&gt;();</code>创建数组，封装结果。</p>
<blockquote>
<p>if(discussPostList!&#x3D;null){<br>            &#x2F;&#x2F; 迭代容器装配用户对应的帖子<br>            for (DiscussPost discussPost : discussPostList) {<br>                Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(16);<br>                map.put(“post”,discussPost);<br>                User user &#x3D; userService.findUserById(discussPost.getUserId());<br>                map.put(“user”,user);</p>
<p>​				long likeCount &#x3D; 	likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_POST.getType(),discussPost.getId());<br>​           	 map.put(“likeCount”,likeCount);<br>​           	userDiscussPosts.add(map);<br>​        }<br>​    }</p>
</blockquote>
<ol>
<li>新建一个 <code>HashMap</code> 对象 <code>map</code>，用于保存该条帖子的信息。</li>
<li>将帖子对象 <code>discussPost</code> 存入 <code>map</code> 中，键为 <code>&quot;post&quot;</code>，值为 <code>discussPost</code>。</li>
<li>通过帖子对象的 <code>userId</code> 属性，调用 <code>userService</code> 的 <code>findUserById</code> 方法，查询发帖用户的信息，并将其存入 <code>map</code> 中，键为 <code>&quot;user&quot;</code>，值为 <code>user</code>。</li>
<li>调用 <code>likeService</code> 的 <code>findEntityLikeCount</code> 方法，统计该帖子的点赞数量（likeCount），并将其存入 <code>map</code> 中，键为 <code>&quot;likeCount&quot;</code>，值为 <code>likeCount</code>。其中&#96;&#96;CommentEntityConstant.ENTITY_TYPE_POST.getType()&#96;是一个标识符，代表是帖子类型。</li>
<li>将 <code>map</code> 添加到 <code>userDiscussPosts</code> 列表中。</li>
</ol>
<p>通过这样的方式，我们可以将每条帖子和它的相关信息都封装为一个 <code>Map</code> 对象，并将多个 <code>Map</code> 对象添加到一个列表中，最终返回给用户。在前端页面上，可以通过遍历这个列表，逐一获取每条记录的各个字段的值，并展示在页面上，以实现帖子列表分页展示等功能。</p>
<blockquote>
<p>model.addAttribute(“discussPosts”,userDiscussPosts);<br>model.addAttribute(“orderMode”,orderMode);<br>return “&#x2F;index”;</p>
</blockquote>
<ol>
<li>调用 <code>model</code> 对象的 <code>addAttribute</code> 方法，将 <code>userDiscussPosts</code> 添加到模型中，并赋予它一个名字 <code>&quot;discussPosts&quot;</code>。</li>
<li>同样地，将排序模式（<code>orderMode</code>）也添加到模型中，名字为 <code>&quot;orderMode&quot;</code>。</li>
<li>最后，使用 <code>return</code> 语句返回 <code>/index</code> 视图名称。由于配置了视图解析器，则会自动寻找并渲染名为 <code>/index</code> 的视图。</li>
</ol>
<p>在 <code>/index</code> 视图中，以此展示帖子列表和排序方式等信息。视图使用模板引擎 Thymeleaf来渲染页面。</p>
<h4 id="功能2：开发注册功能"><a href="#功能2：开发注册功能" class="headerlink" title="功能2：开发注册功能"></a>功能2：开发注册功能</h4><p>​	<strong>流程：</strong></p>
<ul>
<li>访问注册页面<ul>
<li>点击顶部区域内的链接，打开注册页面。</li>
</ul>
</li>
<li>提交注册数据<ul>
<li>通过表单提交数据。</li>
<li>服务端验证账号是否存在，邮箱是否已经注册。</li>
<li>服务端发送激活邮件</li>
</ul>
</li>
<li>激活注册账号<ul>
<li>点击邮件中的链接，访问服务端 的激活服务。</li>
</ul>
</li>
</ul>
<h5 id="1-register以及activation"><a href="#1-register以及activation" class="headerlink" title="(1)register以及activation"></a>(1)register以及activation</h5><pre><code class="java">@RequestMapping(path = &quot;registerPage&quot;,method = RequestMethod.GET)
    public String registerPage()&#123;
        return &quot;site/register&quot;;
    &#125;
    
 @RequestMapping(path = &quot;register&quot;, method = RequestMethod.POST)
    public String register(Model model, User user)&#123;
        Map&lt;String,Object&gt; map = userService.register(user);
        if(map == null || map.isEmpty())&#123;
            model.addAttribute(&quot;msg&quot;,&quot;注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活！&quot;);
            model.addAttribute(&quot;target&quot;,&quot;/index&quot;);
            return &quot;site/operate-result&quot;;
        &#125;else&#123;
            model.addAttribute(&quot;usernameMsg&quot;,map.get(&quot;usernameMsg&quot;));
            model.addAttribute(&quot;passwordMsg&quot;,map.get(&quot;passwordMsg&quot;));
            model.addAttribute(&quot;emailMsg&quot;,map.get(&quot;emailMsg&quot;));
            return &quot;site/register&quot;;
        &#125;
    &#125;

@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;,method = RequestMethod.GET)
    public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId,@PathVariable(&quot;code&quot;) String code)&#123;
        int activationResult = userService.activation(userId, code);
        if(activationResult == ActivationStatus.ACTIVATION_SUCCESS.getCode())&#123;
            model.addAttribute(&quot;msg&quot;,&quot;激活成功,您的账号已经可以正常使用了！&quot;);
            model.addAttribute(&quot;target&quot;,&quot;/user/loginPage&quot;);
        &#125;else if(activationResult == ActivationStatus.ACTIVATION_FAILURE.getCode())&#123;
            model.addAttribute(&quot;msg&quot;,&quot;无效操作，该账号已经激活过了&quot;);
            model.addAttribute(&quot;target&quot;,&quot;/index&quot;);
        &#125;else&#123;
            model.addAttribute(&quot;msg&quot;,&quot;激活失败,您提供的激活码不正确&quot;);
            model.addAttribute(&quot;target&quot;,&quot;/index&quot;);
        &#125;

        return &quot;/site/operate-result&quot;;
    &#125;
</code></pre>
<ol>
<li><code>registerPage()</code>方法是一个GET请求的处理方法，用于返回注册页面视图。在方法中，它直接返回一个字符串”site&#x2F;register”，表示渲染名为”site&#x2F;register.html”的模板文件。</li>
<li><code>register()</code>方法是一个POST请求的处理方法，用于处理用户注册逻辑。其中，它首先调用<code>userService.register(user)</code>方法进行用户注册。如果注册成功，则返回一个激活邮件并给出提示信息，然后跳转到”operate-result.html”页面；否则，把错误信息添加到Model对象中，返回”site&#x2F;register.html”页面重新填写表单。</li>
<li><code>activation()</code>方法是一个GET请求的处理方法，用于处理用户账号激活逻辑。其中，首先调用<code>userService.activation(userId, code)</code>方法对指定用户的账号进行激活。然后，根据激活结果，给出相应的提示信息，并进行相应跳转。最后，返回”operate-result.html”页面展示操作结果。</li>
</ol>
<h4 id="功能3：-开发登录以及退出功能"><a href="#功能3：-开发登录以及退出功能" class="headerlink" title="功能3： 开发登录以及退出功能"></a>功能3： 开发登录以及退出功能</h4><h5 id="1-login与loginout"><a href="#1-login与loginout" class="headerlink" title="(1)login与loginout"></a>(1)login与loginout</h5><pre><code class="java"> @RequestMapping(path = &quot;login&quot;,method = RequestMethod.POST)
    public String login(Model model,/*HttpSession session,*/HttpServletResponse response,
                        String username,String password,String verifyCode,boolean rememberMe,@CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner)&#123;
        String kaptcha=null;
        if(StringUtils.isNotBlank(kaptchaOwner))&#123;
            String kaptchaKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
            kaptcha = (String) redisTemplate.opsForValue().get(kaptchaKey);
        &#125;
        if(StringUtils.isBlank(kaptcha)||StringUtils.isBlank(verifyCode)||!kaptcha.equalsIgnoreCase(verifyCode))&#123;
            model.addAttribute(&quot;codeMsg&quot;,&quot;验证码不正确&quot;);
            return &quot;/site/login&quot;;
        &#125;

        // 检查账号，密码
        int expiredSeconds = rememberMe ? LoginConstant.REMEMBERME_EXPIRED_SECONDS.getExpired():LoginConstant.DEFAULT_EXPIRED_SECONDS.getExpired();
        Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);
        if(map.containsKey(SystemConstant.USER_CREDENTIAL_TICKET))&#123;
            Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());
            cookie.setPath(contextPath);
            cookie.setMaxAge(expiredSeconds);
            response.addCookie(cookie);
            return &quot;redirect:/index&quot;;
        &#125;else&#123;
            model.addAttribute(&quot;usernameMsg&quot;,map.get(&quot;usernameMsg&quot;));
            model.addAttribute(&quot;passwordMsg&quot;,map.get(&quot;passwordMsg&quot;));
            return &quot;site/login&quot;;
        &#125;
    &#125;

    @RequestMapping(path = &quot;logout&quot;,method = RequestMethod.GET)
    public String logout(@CookieValue(&quot;ticket&quot;) String ticket)&#123;
        if(StringUtils.isBlank(ticket))&#123;
            return &quot;index&quot;;
        &#125;
        userService.logout(ticket);
        userThreadLocalHolder.clear();
        SecurityContextHolder.clearContext();
        return &quot;redirect:/user/loginPage&quot;;
    &#125;
</code></pre>
<p>​	</p>
<p><strong>login方法</strong></p>
<p>先看login方法参数：</p>
<ol>
<li><code>Model model</code>：Spring MVC框架中的Model对象，可用于添加属性以在视图中渲染数据。</li>
<li><code>HttpServletResponse response</code>：响应对象，可用于设置响应头信息等。</li>
<li><code>String username</code>：登录表单提交的用户名参数。</li>
<li><code>String password</code>：登录表单提交的密码参数。</li>
<li><code>String verifyCode</code>：登录表单提交的验证码参数。</li>
<li><code>boolean rememberMe</code>：登录提交的用户是否选择了“记住我”。</li>
<li><code>@CookieValue(&quot;kaptchaOwner&quot;)</code>：使用@CookieValue注解获取当前请求中名为”kaptchaOwner”的Cookie值，并将该值赋予变量。其中，”kaptchaOwner”是一个验证码识别标识符，用于区分不同的验证码生成器。</li>
</ol>
<blockquote>
<p>rMe,@CookieValue(“kaptchaOwner”) String kaptchaOwner){<br>        String kaptcha&#x3D;null;<br>        if(StringUtils.isNotBlank(kaptchaOwner)){<br>            String kaptchaKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);<br>            kaptcha &#x3D; (String) redisTemplate.opsForValue().get(kaptchaKey);<br>        }<br>        if(StringUtils.isBlank(kaptcha)||StringUtils.isBlank(verifyCode)||!kaptcha.equalsIgnoreCase(verifyCode)){<br>            model.addAttribute(“codeMsg”,”验证码不正确”);<br>            return “&#x2F;site&#x2F;login”;<br>        }</p>
</blockquote>
<p>验证用户输入的验证码是否正确。具体来说，它首先获取名为”kaptchaOwner”的验证码识别标识符（由前端页面提交），然后利用该标识符构建一个Redis Key，从Redis中获取该验证码对应的值。如果获取到了该值，则比较用户输入的验证码（由前端页面提交）与Redis中存储的验证码是否一致。如果验证码不正确，将错误信息添加到Model对象中，然后返回登录页面”login.html”。</p>
<p>注意，这里使用了StringUtils类进行字符串非空判断。同时，为了避免非法访问，代码中还要对kaptcha参数和verifyCode参数执行Null或空串的检查。</p>
<blockquote>
<p>&#x2F;&#x2F; 检查账号，密码<br>        int expiredSeconds &#x3D; rememberMe ? LoginConstant.REMEMBERME_EXPIRED_SECONDS.getExpired():LoginConstant.DEFAULT_EXPIRED_SECONDS.getExpired();<br>        Map&lt;String, Object&gt; map &#x3D; userService.login(username, password, expiredSeconds);<br>        if(map.containsKey(SystemConstant.USER_CREDENTIAL_TICKET)){<br>            Cookie cookie &#x3D; new Cookie(“ticket”, map.get(“ticket”).toString());<br>            cookie.setPath(contextPath);<br>            cookie.setMaxAge(expiredSeconds);<br>            response.addCookie(cookie);<br>            return “redirect:&#x2F;index”;<br>        }else{<br>            model.addAttribute(“usernameMsg”,map.get(“usernameMsg”));<br>            model.addAttribute(“passwordMsg”,map.get(“passwordMsg”));<br>            return “site&#x2F;login”;<br>        }<br>    }</p>
</blockquote>
<ol>
<li>首先，它调用UserService的login方法验证用户的账号密码是否正确。其中，该方法返回一个Map对象，包含了登录结果和相关信息。</li>
<li>如果登录成功（Map中包含”ticket”键），则将生成的登录凭证（”ticket”）添加到Cookie中，并设置Cookie的过期时间为用户选择的记住登录状态的时间（使用LoginConstant枚举类获取）。然后，将响应重定向到首页”&#x2F;index”。</li>
<li>如果登录失败，则将错误信息添加到Model对象中，并返回到登录页面”login.html”。</li>
</ol>
<p>注意，为了保证安全性，该方法在处理Cookie时，设置了Cookie的Path和Max-Age属性，确保只有指定路径和时限下的页面可以读取该Cookie。同时，为了提高代码的可读性和可维护性，代码中使用了常量枚举类LoginConstant和SystemConstant，避免了硬编码。</p>
<p><strong>logout</strong></p>
<blockquote>
<p>if(StringUtils.isBlank(ticket)){<br>            return “index”;<br>        }<br>        userService.logout(ticket);<br>        userThreadLocalHolder.clear();<br>        SecurityContextHolder.clearContext();<br>        return “redirect:&#x2F;user&#x2F;loginPage”;</p>
</blockquote>
<ol>
<li>首先，它通过@CookieValue注解获取名为”ticket”的Cookie值（该值为用户登录时生成的登录凭证）。</li>
<li>如果获取到了该值，则调用UserService的logout方法，将该登录凭证从数据源中删除。</li>
<li>然后，它清空了UserThreadLocalHolder对象和SecurityContextHolder对象，以确保不会有任何残余的用户信息或权限信息被保留在服务器端。</li>
<li>最后，它将响应重定向到登录页面”login.html”。</li>
</ol>
<p>注意，如果无法获取到名为”ticket”的Cookie值，则默认将响应重定向到”&#x2F;index”。同时，代码中使用了StringUtils类进行字符串非空判断。</p>
<h4 id="功能4：实现登录拦截"><a href="#功能4：实现登录拦截" class="headerlink" title="功能4：实现登录拦截"></a>功能4：实现登录拦截</h4><h5 id="1-提示"><a href="#1-提示" class="headerlink" title="(1)提示"></a>(1)提示</h5><p>详情可见配置类中SecurityConfig以及其它中用户登录权限拦截器</p>
<p>​	。。。</p>
<h4 id="功能5：生成验证码"><a href="#功能5：生成验证码" class="headerlink" title="功能5：生成验证码"></a>功能5：生成验证码</h4><h5 id="1-getKaptcha"><a href="#1-getKaptcha" class="headerlink" title="1.getKaptcha"></a>1.getKaptcha</h5><pre><code class="java">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)
    public void getKaptcha(HttpServletResponse response/*, HttpSession session*/)&#123;
        //生成验证码
        String text = kaptchaProducer.createText();
        BufferedImage image = kaptchaProducer.createImage(text);
        // 验证码归属者,每次刷新验证码，为客户端用户生成临时凭证返回给用户,其中临时凭证存放在cookie中
        String kaptchaOwner = CommonUtil.generateUUID();
        Cookie cookie = new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);
        cookie.setMaxAge(60);
        cookie.setPath(contextPath);
        response.addCookie(cookie);

        // 将验证码存入redis
        String kaptchaKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
        redisTemplate.opsForValue().set(kaptchaKey,text,60, TimeUnit.SECONDS);

        // 将图片输出给浏览器
        response.setContentType(&quot;image/png&quot;);
        try &#123;
            OutputStream os = response.getOutputStream();
            ImageIO.write(image,&quot;png&quot;,os);
        &#125;catch (Exception e)&#123;
            log.error(&quot;验证码生成失败，&#123;&#125;&quot;,e.getMessage());
        &#125;
    &#125;
</code></pre>
<ol>
<li>首先，使用kaptchaProducer对象生成一个验证码字符串（text）和对应的验证码图片（image）。</li>
<li>生成一个随机的字符串作为验证码归属者的唯一标识，并将该字符串存储到Cookie中，以便后续验证时使用。</li>
<li>使用该随机字符串作为键，将验证码字符串存储到Redis中，设置过期时间为60秒。</li>
<li>将生成的验证码图片写入HttpServletResponse对象中，返回给前端页面。</li>
</ol>
<h4 id="功能6：修改密码、找回密码"><a href="#功能6：修改密码、找回密码" class="headerlink" title="功能6：修改密码、找回密码"></a>功能6：修改密码、找回密码</h4><h5 id="1-updatePassword更新密码"><a href="#1-updatePassword更新密码" class="headerlink" title="1.updatePassword更新密码"></a>1.updatePassword更新密码</h5><blockquote>
<pre><code class="java">@RequestMapping(path = &quot;/updatePassword&quot;,method = RequestMethod.POST)
@LoginRequired
public String updatePassword(String originPassword,String newPassword,String repeatPassword,Model model)&#123;
    // 获取当前登录用户信息
    User user = userThreadLocalHolder.getCache();
    model.addAttribute(&quot;originPassword&quot;,originPassword);
    model.addAttribute(&quot;newPassword&quot;,newPassword);
    model.addAttribute(&quot;repeatPassword&quot;,repeatPassword);

    // 密码信息校验
    if(!CommonUtil.md5Encode(originPassword).equals(user.getPassword()))&#123;
        model.addAttribute(&quot;errorMsg1&quot;,&quot;原密码错误&quot;);
        return &quot;site/setting&quot;;
    &#125;

    if(CommonUtil.md5Encode(newPassword).equals(user.getPassword()))&#123;
        model.addAttribute(&quot;errorMsg2&quot;,&quot;新密码不能与原密码一样&quot;);
        return &quot;site/setting&quot;;
    &#125;

    if(!newPassword.equals(repeatPassword))&#123;
        model.addAttribute(&quot;errorMsg3&quot;,&quot;两次输入密码不一致&quot;);
        return &quot;site/setting&quot;;
    &#125;

    user.setPassword(CommonUtil.md5Encode(newPassword));
    int result = userService.updatePassword(user);
    if(result&lt;=0)&#123;
        model.addAttribute(&quot;errorMsg&quot;,&quot;更新密码失败&quot;);
        return &quot;site/setting&quot;;
    &#125;

    return &quot;redirect:/index&quot;;
&#125;
</code></pre>
</blockquote>
<p><strong>思路：</strong></p>
<p>首先，代码使用RequestMapping注解指定了该方法的访问路径为”&#x2F;updatePassword”，请求方式为POST。同时，通过@LoginRequired自定义注解标记该方法需要登录才能访问。</p>
<p>接下来，代码通过方法入参获取用户输入的原密码、新密码和重复密码，并将这些参数及原有密码一同加入到Model对象中，方便在返回视图中进行校验和渲染。</p>
<p>然后，代码对用户输入的密码进行校验。首先判断用户输入的原密码是否与当前登录用户的密码匹配，若不匹配，则向Model对象中添加一个errorMsg1属性，表示原密码错误。如果新密码与原密码一致，则向Model对象中添加一个errorMsg2属性，表示新密码不能与原密码一样。如果确认新密码和重复密码不一致，则向Model对象中添加一个errorMsg3属性，表示两次输入密码不一致。</p>
<p>若以上校验都通过，则将新密码使用md5加密，并更新到当前登录用户中。代码调用userService中的updatePassword方法更新用户密码，并根据返回值判断更新操作是否成功，如果成功则通过重定向跳转到首页，否则返回设置页面并向Model对象中添加一个errorMsg属性，表示更新密码失败。</p>
<p>最终，该方法会返回一个String类型的视图名称，代码通过”redirect:&#x2F;index”实现重定向到首页。</p>
<h5 id="2-forgetPwd忘记密码"><a href="#2-forgetPwd忘记密码" class="headerlink" title="2.forgetPwd忘记密码"></a>2.forgetPwd忘记密码</h5><pre><code class="java">@RequestMapping(path = &quot;/forgetPwd&quot;,method = RequestMethod.POST)
    public String forgetPwd(Model model,String email,String verifyCode,String newPassword,HttpSession session,@CookieValue String verifyEmail)&#123;
        // 非空校验
        if(StringUtils.isBlank(email))&#123;
            model.addAttribute(&quot;emailMsg&quot;,&quot;邮箱为空&quot;);
            return &quot;/site/forget&quot;;
        &#125;
        if(StringUtils.isBlank(verifyCode))&#123;
            model.addAttribute(&quot;verifyCodeMsg&quot;,&quot;验证码为空&quot;);
            return &quot;/site/forget&quot;;
        &#125;
        if(StringUtils.isBlank(newPassword))&#123;
            model.addAttribute(&quot;passwordMsg&quot;,&quot;密码为空&quot;);
            return &quot;/site/forget&quot;;
        &#125;

        model.addAttribute(&quot;email&quot;,email);
        model.addAttribute(&quot;verifyCode&quot;,verifyCode);
        model.addAttribute(&quot;newPassword&quot;,newPassword);

        // 检查验证码
        String emailVerifyCode = (String) session.getAttribute(&quot;verifyCode&quot;);
        if(StringUtils.isBlank(emailVerifyCode)||StringUtils.isBlank(emailVerifyCode)||!verifyCode.equalsIgnoreCase(emailVerifyCode))&#123;
            model.addAttribute(&quot;verifyCodeMsg&quot;,&quot;验证码不正确&quot;);
            return &quot;/site/forget&quot;;
        &#125;

        if(CommonUtil.isEmtpy(verifyEmail))&#123;
            model.addAttribute(&quot;verifyCodeMsg&quot;,&quot;验证码超时&quot;);
            return &quot;/site/forget&quot;;
        &#125;

        //验证邮箱
        User user = userService.findUserByEmail(email);
        if(CommonUtil.isEmtpy(user))&#123;
            model.addAttribute(&quot;emailMsg&quot;,&quot;邮箱不存在&quot;);
            return &quot;/site/forget&quot;;
        &#125;else&#123;
            // 检查密码
            if(CommonUtil.md5Encode(newPassword).equals(user.getPassword()))&#123;
                model.addAttribute(&quot;passwordMsg&quot;,&quot;新密码不能和原密码一致&quot;);
                return &quot;/site/forget&quot;;
            &#125;else&#123;
                // 执行插入操作
                user.setPassword(CommonUtil.md5Encode(newPassword));
                int result = userService.updatePassword(user);
                if(result&lt;=0)&#123;
                    model.addAttribute(&quot;errorMsg&quot;,&quot;重置密码失败!&quot;);
                    return &quot;/site/forget&quot;;
                &#125;
            &#125;
        &#125;
        return &quot;/site/login&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>忘记密码的重置功能，具体来说：</p>
<p>首先，代码使用RequestMapping注解指定了该方法的访问路径为”&#x2F;forgetPwd”，请求方式为POST。该方法用于接收用户提交的邮箱、验证码和新密码，并进行校验和重置操作。</p>
<p>接下来，代码对入参进行非空校验，同时将入参添加到Model对象中，方便在视图中显示和渲染。</p>
<p>然后，代码从 HttpSession 中获取系统生成的验证码，并将用户输入的验证码与系统生成的验证码进行比较，如果不一致则向Model对象中添加一个verifyCodeMsg属性，表示验证码不正确。如果从Cookie中获取的验证码为空，则向Model对象中再添加一个verifyCodeMsg属性，表示验证码超时。</p>
<p>如果验证码校验通过，则代码通过邮箱查找用户信息，如果用户不存在，则向Model对象中添加一个emailMsg属性，表示邮箱不存在；如果用户存在，则再次校验新密码是否与原密码一致，如果一致则向Model对象中添加一个passwordMsg属性，表示新密码不能与原密码一致。否则，将新密码进行md5加密后更新到用户信息中，并调用userService中的updatePassword方法执行更新操作，如果更新失败则向Model对象中添加一个errorMsg属性，表示重置密码失败。</p>
<p>最终，如果操作成功，则重定向到登录页面；否则，仍然返回到重置密码页面并显示错误信息。</p>
<h5 id="3-emailVerify邮箱验证"><a href="#3-emailVerify邮箱验证" class="headerlink" title="3.emailVerify邮箱验证"></a>3.emailVerify邮箱验证</h5><pre><code class="java">@RequestMapping(path = &quot;/emailVerify&quot;,method = RequestMethod.POST)
    public void emailVerify(HttpSession session,String email,HttpServletResponse response)&#123;
        String verifyCode = CommonUtil.generateUUID().substring(0, 6);
        session.setAttribute(&quot;verifyCode&quot;,verifyCode);

        if(CommonUtil.isEmtpy(email))&#123;
            throw new CustomizeException(ResultEnum.EMAIL_NOT_EXIST,&quot;emailVerify()&quot;);
        &#125;
        // 调用service发送验证码邮件
        userService.sendVerifyEmail(verifyCode,email);

        // 生成一个cookie，用于判断验证码是否失效
        Cookie cookie = new Cookie(&quot;verifyEmail&quot;, CommonUtil.generateUUID());
        cookie.setPath(contextPath);
        cookie.setDomain(domain);
        cookie.setMaxAge(SysEmailConstant.EMAIL_VERIFYCODE_EXPIRED.getSec());

        response.addCookie(cookie);
    &#125;
&#125;
</code></pre>
<p><strong>思路</strong>：</p>
<p>代码使用RequestMapping注解指定该方法的访问路径为”&#x2F;emailVerify”，请求方式为POST。该方法用于接收用户提交的邮箱，并生成一个随机的验证码，并将该验证码存储在HttpSession中，同时调用userService的sendVerifyEmail方法将验证码发送到用户邮箱中。</p>
<p>然后，代码生成一个cookie，用于判断验证码是否失效。cookie的名字为”verifyEmail”，值为一个随机生成的UUID字符串，其最大生命周期为SysEmailConstant.EMAIL_VERIFYCODE_EXPIRED.getSec()秒（即120秒），路径为contextPath，域名为domain。</p>
<p>最终，将cookie添加到HttpServletResponse中返回给用户浏览器。</p>
<h4 id="功能7：上传更新头像"><a href="#功能7：上传更新头像" class="headerlink" title="功能7：上传更新头像"></a>功能7：上传更新头像</h4><pre><code class="java">@LoginRequired
@RequestMapping(path = &quot;/settings&quot;,method = RequestMethod.GET)
public String getSettingsPage(Model model)&#123;

        // 上传文件名称 -&gt; 目的：服务器缓存无效，上传历史保留
        String fileName = CommonUtil.generateUUID();

        // 设置响应信息
        StringMap policy = new StringMap();
//        policy.put(&quot;returnBody&quot;, CommonUtil.getJsonString(0,&quot;生成成功&quot;));
        policy.put(&quot;returnBody&quot;, CommonUtil.getJsonString(0));

        // 生成七牛云上传凭证
        Auth auth = Auth.create(accessKey, secretKey);
        String uploadToken = auth.uploadToken(headerBucketName, fileName, 3600, policy);

        model.addAttribute(&quot;uploadToken&quot;,uploadToken);
        model.addAttribute(&quot;fileName&quot;,fileName);
        return &quot;site/setting&quot;;
    &#125;

    /**
     * 更新头像路径(异步访问)：
     *      更新为七牛云服务器的路径
     * @param fileName
     * @return
     */
    @RequestMapping(path = &quot;/header/url&quot;,method = RequestMethod.POST)
    @ResponseBody
    @ApiOperation(value = &quot;更新头像url地址&quot;)
    public String updateHeaderUrl(String fileName)&#123;
        if (StringUtils.isBlank(fileName))&#123;
            return CommonUtil.getJsonString(1,&quot;文件名不能为空&quot;);
        &#125;

        String url = headerBucketUrl + &quot;/&quot; + fileName;
        userService.updateHeader(userThreadLocalHolder.getCache().getId(),url);

        return CommonUtil.getJsonString(0,&quot;success&quot;);
    &#125;
    
    
    @RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;,method = RequestMethod.GET)
    @LoginRequired
    public void getHeader(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response)&#123;
        // 获取用户头像文件存放路径
        File file = new File(uploadPath + &quot;/&quot; + fileName);
        // 文件后缀
        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));

        // 响应图片
        response.setContentType(&quot;img/&quot;+suffix);

        try (OutputStream os = response.getOutputStream();
             FileInputStream fis = new FileInputStream(file);)&#123;

            byte[] buffer = new byte[1024];
            int offset = 0;
            while ((offset=fis.read(buffer))!=-1)&#123;
                os.write(buffer,0,offset);
            &#125;
        &#125; catch (IOException e) &#123;
            log.error(&quot;读取头像失败:&#123;&#125;&quot;,e.getMessage());
        &#125;
    &#125;
</code></pre>
<h6 id="1-getSettingsPage"><a href="#1-getSettingsPage" class="headerlink" title="1.getSettingsPage"></a>1.<strong>getSettingsPage</strong></h6><blockquote>
<p>&#x2F;&#x2F; 上传文件名称 -&gt; 目的：服务器缓存无效，上传历史保留 </p>
<p>String fileName &#x3D; CommonUtil.generateUUID(); &#x2F;&#x2F; 设置响应信息 StringMap policy &#x3D; new StringMap();</p>
<p>&#x2F;&#x2F;  policy.put(“returnBody”, CommonUtil.getJsonString(0,”生成成功”));<br> policy.put(“returnBody”, CommonUtil.getJsonString(0));</p>
<p>&#x2F;&#x2F; 生成七牛云上传凭证</p>
<p> Auth auth &#x3D; Auth.create(accessKey, secretKey); </p>
<p>String uploadToken &#x3D; auth.uploadToken(headerBucketName, fileName, 3600, policy);</p>
</blockquote>
<p>该方法使用@RequestMapping注解标记，指定了访问该方法的请求路径和请求方式为GET。当访问该路径时，该方法将上传文件所需的信息存入Model对象，并返回一个名为”site&#x2F;setting”的视图。</p>
<p>代码创建了一个Auth对象，指定了accessKey和secretKey，这两个参数是调用七牛云API时使用的密钥信息。</p>
<p>然后，通过Auth对象的uploadToken方法生成上传凭证，需要传入以下参数：</p>
<ul>
<li>bucket：指定上传空间。</li>
<li>key：指定上传文件名，一般使用随机字符串避免文件名重复。</li>
<li>expires：指定凭证的过期时间，单位为秒。在本代码中，设置为3600秒（1小时）。</li>
<li>policy：指定上传策略，是一个包含多个上传参数的Map对象。该策略通常包含上传成功后返回的信息和其他限制条件，如对上传文件大小、类型、数量等的限制。</li>
</ul>
<p>最后，代码将生成的上传凭证和文件名存储到Model对象中，以便前端页面获取并使用,由前端向七牛云上传接口上传新头像。</p>
<h6 id="2-updateHeaderUrl"><a href="#2-updateHeaderUrl" class="headerlink" title="2.updateHeaderUrl"></a>2.<strong>updateHeaderUrl</strong></h6><blockquote>
<p>if (StringUtils.isBlank(fileName)){<br>            return CommonUtil.getJsonString(1,”文件名不能为空”);<br>        }</p>
<p>String url &#x3D; headerBucketUrl + “&#x2F;“ + fileName;<br>userService.updateHeader(userThreadLocalHolder.getCache().getId(),url);</p>
<p>return CommonUtil.getJsonString(0,”success”);</p>
</blockquote>
<p>如果上传文件名为空，则返回一个JSON格式的错误提示信息，其中1表示错误代码，”文件名不能为空”为错误提示信息。</p>
<p>否则，代码将上传文件的完整URL生成，并调用userService的updateHeader方法更新该用户的头像信息。其中，userThreadLocalHolder.getCache().getId()用于获取当前用户的ID，headerBucketUrl是头像空间的URL地址，在该地址后面拼接上上传的文件名即可获取到头像文件的完整URL。</p>
<p>最终，代码返回一个JSON格式的字符串，表示操作成功，其中0表示操作代码，”success”为成功提示信息。</p>
<h6 id="3-getHeader"><a href="#3-getHeader" class="headerlink" title="3.getHeader"></a>3.<strong>getHeader</strong></h6><blockquote>
<p>@RequestMapping(path &#x3D; “&#x2F;header&#x2F;{fileName}”,method &#x3D; RequestMethod.GET)<br>@LoginRequired<br>public void getHeader(@PathVariable(“fileName”) String fileName, HttpServletResponse response){<br>    &#x2F;&#x2F; 获取用户头像文件存放路径<br>    File file &#x3D; new File(uploadPath + “&#x2F;“ + fileName);<br>    &#x2F;&#x2F; 文件后缀<br>    String suffix &#x3D; fileName.substring(fileName.lastIndexOf(“.”));</p>
<p>&#x2F;&#x2F; 响应图片<br>response.setContentType(“img&#x2F;“+suffix);</p>
<p>try (OutputStream os &#x3D; response.getOutputStream();<br>     FileInputStream fis &#x3D; new FileInputStream(file);){</p>
<p>byte[] buffer &#x3D; new byte[1024];<br>int offset &#x3D; 0;<br>while ((offset&#x3D;fis.read(buffer))!&#x3D;-1){<br>    os.write(buffer,0,offset);<br>}</p>
<p>} catch (IOException e) {<br>    log.error(“读取头像失败:{}”,e.getMessage());<br>}</p>
<p>}</p>
</blockquote>
<p>用于获取用户的头像文件并响应到前台展示。具体来说：</p>
<p>首先，代码使用RequestMapping注解指定了该方法的访问路径为”&#x2F;header&#x2F;{fileName}”，请求方式为GET。其中，{fileName}表示一个占位符，实际请求路径中的值会被赋值给方法入参中的@PathVariable(“fileName”) String fileName变量。</p>
<p>接下来，代码通过@LoginRequired注解标记该方法需要登录才能访问。图片资源的访问权限需要控制，这里使用自定义注解@LoginRequired拦截未登录用户的请求。</p>
<p>如果用户头像文件存在，则将文件后缀名读取出来并设置response的ContentType为”image&#x2F;“ + suffix，以表明响应的是一张图片。接着，代码使用try-with-resources语句创建输出流和输入流，并通过循环读取数据的方式，将文件内容写入输出流中。最后，通过IOException类型的异常处理机制，对异常进行捕获和处理。</p>
<p>因为该方法没有返回值，所以前端页面会直接接收到响应数据并展示图片，而不需要再进行二次渲染。</p>
<h6 id="4-对应前端js代码"><a href="#4-对应前端js代码" class="headerlink" title="4.对应前端js代码"></a>4.对应前端js代码</h6><pre><code class="js"> $.ajax(&#123;
        url: &quot;http://upload-z2.qiniup.com&quot;, // 华南存储url
        method: &quot;post&quot;,
        processData: false, // 不要把表单内容转换成字符串，由浏览器自行判断
        contentType: false, // 上传数据类型不指定，浏览器自动设置，数据边界key由浏览器自动生成
        data: new FormData($(&quot;#uploadForm&quot;)[0]),
        success: function(data) &#123;
            if(data &amp;&amp; data.code == 0) &#123;
                // 更新头像访问路径
                $.post(
                    PROJECT_ROOT + &quot;/user/header/url&quot;,
                    &#123;&quot;fileName&quot;:$(&quot;input[name=&#39;key&#39;]&quot;).val()&#125;,
                    function(data) &#123;
                        data = $.parseJSON(data);
                        if(data.code == 0) &#123;
                            window.location.reload();
                            alert(&quot;上传成功!&quot;);
                        &#125; else &#123;
                            alert(data.msg);
                        &#125;
                    &#125;
                );
            &#125; else &#123;
                alert(&quot;上传失败!&quot;);
            &#125;
</code></pre>
<p>使用AJAX技术实现了上传文件到七牛云存储的功能。具体来说：</p>
<p>首先，代码指定了七牛云存储的上传接口URL地址，通过POST方法向该接口提交FormData数据格式的文件上传请求。其中，processData和contentType设置为false，表示不对表单数据进行转换，并由浏览器自动判断和生成数据边界key。</p>
<p>接下来，代码将表单数据转换成FormData对象，并作为data参数传递给请求的回调函数。如果上传成功，会返回一个JSON格式的响应数据。如果响应数据中的code值为0，则表示上传成功，代码会调用$.post()方法向服务器发送更新头像访问路径的请求。请求的url为PROJECT_ROOT + “&#x2F;user&#x2F;header&#x2F;url”，其中PROJECT_ROOT是项目根目录的URL地址。请求的参数为上传文件名fileName，由input标签中的name属性为”key”的hidden元素的value值指定。</p>
<p>最后，代码解析服务器返回的JSON数据，并根据操作结果显示一个提示框。如果操作成功，则刷新页面并弹出”上传成功”的提示框；如果操作失败，则弹出”上传失败”的提示框。</p>
<h4 id="功能8：用户个人资料"><a href="#功能8：用户个人资料" class="headerlink" title="功能8：用户个人资料"></a>功能8：用户个人资料</h4><h5 id="1-getProfilePage"><a href="#1-getProfilePage" class="headerlink" title="1.getProfilePage"></a>1.getProfilePage</h5><pre><code class="java">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;,method = RequestMethod.GET)
    @LoginRequired
    public String getProfilePage(Model model,@PathVariable(&quot;userId&quot;) int userId)&#123;
        User user = userService.findUserById(userId);
        if(CommonUtil.isEmtpy(user))&#123;
            throw new RuntimeException(&quot;用户登录异常&quot;);
        &#125;
        // 用户信息
        model.addAttribute(&quot;user&quot;,user);

        // 显示正确的点赞数量、关注数量、粉丝数量、用户关注状态
        // 点赞数量
        int userLikeCount = likeService.findUserLikeCount(userId);
        model.addAttribute(&quot;userLikeCount&quot;,userLikeCount);

        // 关注数量
        long followeeCount = followService.findFolloweeCount(userId, CommentEntityConstant.ENTITY_TYPE_USER.getType());
        model.addAttribute(&quot;followeeCount&quot;,followeeCount);


        // 粉丝数量
        long followerCount = followService.findFollowerCount(CommentEntityConstant.ENTITY_TYPE_USER.getType(), userId);
        model.addAttribute(&quot;followerCount&quot;,followerCount);

        // 是否已关注
        boolean hasFollowed = false;
        if(!CommonUtil.isEmtpy(userThreadLocalHolder.getCache()))&#123;
            hasFollowed = followService.hasFollowed(userThreadLocalHolder.getCache().getId(),CommentEntityConstant.ENTITY_TYPE_USER.getType(),userId);
        &#125;
        model.addAttribute(&quot;hasFollowed&quot;,hasFollowed);

        return &quot;/site/profile&quot;;
    &#125;
</code></pre>
<p>用户个人资料页面的展示，具体来说：</p>
<p>首先，代码使用RequestMapping注解指定该方法的访问路径为”&#x2F;profile&#x2F;{userId}”，请求方式为GET。其中，userId为PathVariable注解指定的路径参数，用于表示要展示的用户的ID。</p>
<p>接下来，代码使用@LoginRequired注解进行登录校验，只有已登录的用户才能访问该页面。</p>
<p>然后，代码调用userService的findUserById方法查询要展示的用户信息，并将结果存储在Model对象中，以便在视图中显示和渲染。</p>
<p>接下来，代码分别查询该用户的点赞数量、关注数量和粉丝数量，并将结果存储在Model对象中，以便在视图中显示和渲染。</p>
<p>然后，代码判断当前登录的用户是否已关注被展示用户，如果已关注则将hasFollowed属性设置为true，否则设置为false，并将结果存储在Model对象中，以便在视图中显示和渲染。</p>
<p>最终，代码返回”&#x2F;site&#x2F;profile”视图页面，用于展示用户个人资料的详细信息。</p>
<h5 id="2-getMyPostPage"><a href="#2-getMyPostPage" class="headerlink" title="2.getMyPostPage"></a>2.getMyPostPage</h5><pre><code class="java">@RequestMapping(path = &quot;/mypost&quot;,method = RequestMethod.GET)
    @LoginRequired
    public String getMyPostPage(Model model, PageInfo pageInfo)&#123;
        // 获取当前登录用户信息
        User user = userThreadLocalHolder.getCache();
        int discussPostCount = discussPostService.findDiscussPostCount(user.getId());
        model.addAttribute(&quot;discussPostCount&quot;,discussPostCount);

        // 设置分页信息
        pageInfo.setPath(&quot;/user/mypost&quot;);
        pageInfo.setLimit(5);
        pageInfo.setRows(discussPostCount);

        // 查询帖子列表
        List&lt;DiscussPost&gt; discussPosts = discussPostService.findDiscussPostList(user.getId(), pageInfo.getOffset(), pageInfo.getLimit(),0);
        model.addAttribute(&quot;discussPosts&quot;,discussPosts);
        return &quot;/site/my-post&quot;;
    &#125;
</code></pre>
<p><strong>思路</strong>：</p>
<p>用户个人帖子列表页面的展示，具体来说：</p>
<p>首先，代码使用RequestMapping注解指定该方法的访问路径为”&#x2F;mypost”，请求方式为GET。该方法用于展示当前登录用户发布的帖子列表。</p>
<p>然后，代码使用@LoginRequired注解进行登录校验，只有已登录的用户才能访问该页面。</p>
<p>接着，代码获取当前登录用户信息，并使用discussPostService的findDiscussPostCount方法查询当前登录用户发布的帖子数量，并将结果存储在Model对象中，以便在视图中显示和渲染。</p>
<p>接下来，代码设置分页信息，其中Path属性指定了分页的请求路径为&#x2F;user&#x2F;mypost，Limit属性指定了每页显示的帖子数量为5，Rows属性则指定了总帖子数，用以计算分页。</p>
<p>然后，代码调用discussPostService的findDiscussPostList方法查询当前登录用户所发布的帖子列表，并将结果存储在Model对象中，以便在视图中显示和渲染。</p>
<p>最终，代码返回”&#x2F;site&#x2F;my-post”视图页面，用于展示当前登录用户发布的所有帖子列表。</p>
<h3 id="DiscussPostController-java"><a href="#DiscussPostController-java" class="headerlink" title="DiscussPostController.java"></a>DiscussPostController.java</h3><h4 id="需要注入的Bean-1"><a href="#需要注入的Bean-1" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">@Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private UserService userService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private CommentService commentService;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;
</code></pre>
<h4 id="功能9：添加帖子"><a href="#功能9：添加帖子" class="headerlink" title="功能9：添加帖子"></a>功能9：添加帖子</h4><h5 id="1-addDiscussPost"><a href="#1-addDiscussPost" class="headerlink" title="1.addDiscussPost"></a>1.addDiscussPost</h5><pre><code class="java"> @RequestMapping(path = &quot;/add&quot;,method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    @ApiOperation(value = &quot;添加帖子&quot;)
    public String addDiscussPost(String title,String content)&#123;
        User user = userThreadLocalHolder.getCache();
        if(CommonUtil.isEmtpy(user))&#123;
            return CommonUtil.getJsonString(403,&quot;你还没有登录哦!&quot;);
        &#125;

        DiscussPost discussPost = new DiscussPost();
        discussPost.setUserId(user.getId());
        discussPost.setTitle(title);
        discussPost.setContent(content);
        discussPost.setCreateTime(new Date());
        discussPostService.addDiscussPost(discussPost);

        // 触发发帖事件,将新发布的帖子异步同步到es服务器
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_PUBLISH)
                .setUserId(user.getId())
                .setEntityType(CommentEntityConstant.ENTITY_TYPE_POST.getType())
                .setEntityId(discussPost.getId());

        eventProducer.handleEvent(event);

        // 计算帖子分数
        String postScoreKey = RedisKeyUtil.getPostScoreKey();
        redisTemplate.opsForSet().add(postScoreKey,discussPost.getId());


        // 报错的情况在全局异常处理器中处理
        return CommonUtil.getJsonString(200,&quot;发布成功&quot;);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>代码使用@RequestMapping注解指定该方法的访问路径为”&#x2F;add”，请求方式为POST。该方法用于处理用户发布的帖子内容。</p>
<p>然后，代码使用@ResponseBody注解将方法返回值序列化成JSON格式返回给客户端。</p>
<p>接着，使用@LoginRequired注解进行登录校验，只有已登录的用户才能访问该功能。</p>
<p>然后，代码获取当前登录用户信息，并判断用户是否为空，如果为空则返回错误提示信息。</p>
<p>接下来，代码创建一个DiscussPost对象，设置其userId、title、content和createTime属性，并调用discussPostService的addDiscussPost方法将帖子保存到数据库中。</p>
<p>然后，代码创建一个Event对象，用于异步地将新发布的帖子同步到ES服务器中，并将其发送到事件队列中，以便其他相关服务可以及时地处理该事件。</p>
<p>接下来，代码计算帖子分数，并将其添加到Redis的帖子分数集合中。</p>
<p>最终，代码返回JSON格式的字符串，其中200表示发布成功，403表示用户未登录。如果出现异常，则在全局异常处理器中进行处理。</p>
<h4 id="功能10：帖子详情"><a href="#功能10：帖子详情" class="headerlink" title="功能10：帖子详情"></a>功能10：帖子详情</h4><h5 id="1-getDiscussPost"><a href="#1-getDiscussPost" class="headerlink" title="1.getDiscussPost"></a>1.getDiscussPost</h5><pre><code class="java">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;,method = RequestMethod.GET)
    @LoginRequired
    public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, PageInfo pageInfo)&#123;
        // 查询帖子
        DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
        model.addAttribute(&quot;post&quot;,post);

        // 查询作者
        User user = userService.findUserById(post.getUserId());
        model.addAttribute(&quot;user&quot;,user);

        // 点赞
        // 点赞数量
        long likeCount = likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_POST.getType(),discussPostId);
        model.addAttribute(&quot;likeCount&quot;,likeCount);
        // 点赞状态
        int likeStatus = userThreadLocalHolder.getCache()==null ? 0:likeService.findEntityLikeStatus(userThreadLocalHolder.getCache().getId(),CommentEntityConstant.ENTITY_TYPE_POST.getType(),discussPostId);
        model.addAttribute(&quot;likeStatus&quot;,likeStatus);

        // 分页查询帖子评论
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/discuss/detail/&quot; + discussPostId);
        pageInfo.setRows(post.getCommentCount());
        List&lt;Comment&gt; commentList = commentService.findCommentByEntity(CommentEntityConstant.ENTITY_TYPE_POST.getType(), post.getId(), pageInfo.getOffset(), pageInfo.getLimit());

        // 封装所有查询到的结果
        // 评论：给帖子的评论
        // 回复：给评论的评论
        // 评论列表
        List&lt;Map&lt;String,Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();
        if(!CommonUtil.isEmtpy(commentList))&#123;
            for (Comment comment:commentList)&#123;
                // 一个评论的VO
                Map&lt;String,Object&gt; commentVo = new HashMap&lt;&gt;(10);
                // 评论
                commentVo.put(&quot;comment&quot;,comment);
                // 评论作者
                commentVo.put(&quot;user&quot;,userService.findUserById(comment.getUserId()));
                // 回复列表：评论的评论
                List&lt;Comment&gt; replyList = commentService.findCommentByEntity(CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(), comment.getId(), 0, Integer.MAX_VALUE);
                // 点赞数量
                likeCount = likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(),comment.getId());
                commentVo.put(&quot;likeCount&quot;,likeCount);
                // 点赞状态
                likeStatus = userThreadLocalHolder.getCache()==null ? 0:likeService.findEntityLikeStatus(userThreadLocalHolder.getCache().getId(),CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(),comment.getId());
                commentVo.put(&quot;likeStatus&quot;,likeStatus);
                // 回复VO列表
                List&lt;Map&lt;String,Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();
                if(!CommonUtil.isEmtpy(replyList))&#123;
                    for(Comment reply:replyList)&#123;
                        Map&lt;String,Object&gt; replyVo = new HashMap&lt;&gt;(10);
                        // 回复
                        replyVo.put(&quot;reply&quot;,reply);
                        // 作者
                        replyVo.put(&quot;user&quot;,userService.findUserById(reply.getUserId()));
                        // 点赞数量
                        likeCount = likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(),reply.getId());
                        replyVo.put(&quot;likeCount&quot;,likeCount);
                        // 点赞状态
                        likeStatus = userThreadLocalHolder.getCache()==null ? 0:likeService.findEntityLikeStatus(userThreadLocalHolder.getCache().getId(),CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(),reply.getId());
                        replyVo.put(&quot;likeStatus&quot;,likeStatus);
                        // 回复目标
                        User target = reply.getTargetId()==0?null:userService.findUserById(reply.getTargetId());
                        replyVo.put(&quot;target&quot;,target);

                        replyVoList.add(replyVo);
                    &#125;
                &#125;

                commentVo.put(&quot;replys&quot;,replyVoList);

                // 回复数量
                int replyCount = commentService.findCommentCount(CommentEntityConstant.ENTITY_TYPE_COMMENT.getType(), comment.getId());
                commentVo.put(&quot;replyCount&quot;,replyCount);
                commentVoList.add(commentVo);
            &#125;
        &#125;

        model.addAttribute(&quot;comments&quot;,commentVoList);

        return &quot;site/discuss-detail&quot;;
    &#125;
</code></pre>
<p><strong>思路</strong></p>
<p>使用@RequestMapping注解指定该方法的访问路径为”&#x2F;detail&#x2F;{discussPostId}”，请求方式为GET。该方法用于处理用户查看帖子详情的请求。</p>
<p>然后，使用@LoginRequired注解进行登录校验，只有已登录的用户才能访问该功能。</p>
<p>接着，获取路径中的discussPostId参数，并通过discussPostService的findDiscussPostById方法查询对应的帖子信息，并将其设置到Model中。</p>
<p>然后，通过userService的findUserById方法查询帖子作者信息，并将其设置到Model中。</p>
<p>接下来，通过likeService的findEntityLikeCount和findEntityLikeStatus方法获取帖子点赞数量和点赞状态，并将其设置到Model中。</p>
<p>然后，通过commentService的findCommentByEntity方法分页查询帖子评论，并通过对评论和回复进行封装，将结果设置到Model中，以便在页面上展示帖子评论和回复列表。</p>
<p>最后，将Model返回到控制器视图层&#x2F;site&#x2F;discuss-detail中，用于展示帖子详情页面。</p>
<h4 id="功能11：帖子置顶"><a href="#功能11：帖子置顶" class="headerlink" title="功能11：帖子置顶"></a>功能11：帖子置顶</h4><h5 id="1-setTop"><a href="#1-setTop" class="headerlink" title="1.setTop"></a>1.setTop</h5><pre><code class="java">@RequestMapping(path = &quot;/top&quot;,method = RequestMethod.POST)
    @ResponseBody
    @ApiOperation(value = &quot;帖子置顶&quot;)
    public String setTop(int id)&#123;
        User user = userThreadLocalHolder.getCache();
        if(CommonUtil.isEmtpy(user))&#123;
            return CommonUtil.getJsonString(403,&quot;你还没有登录哦!&quot;);
        &#125;
        // 1 帖子状态置顶
        discussPostService.updateType(id,1);

        // 触发一次发帖事件，异步同步到es服务器中，使得能够搜索到最新的帖子
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_PUBLISH)
                .setUserId(user.getId())
                .setEntityType(CommentEntityConstant.ENTITY_TYPE_POST.getType())
                .setEntityId(id);

        eventProducer.handleEvent(event);
        return CommonUtil.getJsonString(0);
    &#125;
</code></pre>
<p><strong>思路</strong></p>
<p>先，使用@RequestMapping注解指定该方法的访问路径为”&#x2F;top”，请求方式为POST。该方法用于处理将帖子置顶的请求。</p>
<p>然后，使用@ResponseBody注解指定返回值为json字符串。</p>
<p>接着，使用@ApiOperation注解对方法进行描述，说明该方法实现的功能是帖子置顶。</p>
<p>然后，通过参数id获取要置顶的帖子的id。</p>
<p>接下来，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，如果该用户未登录，则返回登录提示信息。</p>
<p>然后，通过discussPostService的updateType方法更新帖子状态为置顶状态（type参数值为1）。</p>
<p>接着，创建一个事件event，设置其topic、userId、entityType和entityId属性，并通过eventProducer的handleEvent方法将该事件加入到消息队列中，等待异步处理。</p>
<p>最后，使用CommonUtil.getJsonString方法返回操作结果的json字符串，其中code为0表示操作成功。</p>
<h4 id="功能12：帖子加精"><a href="#功能12：帖子加精" class="headerlink" title="功能12：帖子加精"></a>功能12：帖子加精</h4><h5 id="1-setFine"><a href="#1-setFine" class="headerlink" title="1.setFine"></a>1.setFine</h5><pre><code class="java"> @RequestMapping(path = &quot;/fine&quot;,method = RequestMethod.POST)
    @ResponseBody
    @ApiOperation(value = &quot;帖子加精&quot;)
    public String setFine(int id)&#123;
        User user = userThreadLocalHolder.getCache();
        if(CommonUtil.isEmtpy(user))&#123;
            return CommonUtil.getJsonString(403,&quot;你还没有登录哦!&quot;);
        &#125;
        // 1 帖子状态置顶
        discussPostService.updateStatus(id,1);

        // 触发一次发帖事件，异步同步到es服务器中，使得能够搜索到最新的帖子
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_PUBLISH)
                .setUserId(user.getId())
                .setEntityType(CommentEntityConstant.ENTITY_TYPE_POST.getType())
                .setEntityId(id);

        eventProducer.handleEvent(event);
        // 记录影响帖子分数帖子id
        String postScoreKey = RedisKeyUtil.getPostScoreKey();
        redisTemplate.opsForSet().add(postScoreKey,id);
        return CommonUtil.getJsonString(0);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，使用@RequestMapping注解指定该方法的访问路径为”&#x2F;fine”，请求方式为POST。该方法用于处理将帖子设为加精状态的请求。</p>
<p>然后，使用@ResponseBody注解指定返回值为json字符串。</p>
<p>接着，使用@ApiOperation注解对方法进行描述，说明该方法实现的功能是帖子加精。</p>
<p>然后，通过参数id获取要加精的帖子的id。</p>
<p>接下来，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，如果该用户未登录，则返回登录提示信息。</p>
<p>然后，通过discussPostService的updateStatus方法更新帖子状态为加精状态（status参数值为1）。</p>
<p>接着，创建一个事件event，设置其topic、userId、entityType和entityId属性，并通过eventProducer的handleEvent方法将该事件加入到消息队列中，等待异步处理。</p>
<p>然后，使用redisTemplate.opsForSet().add方法将该帖子id添加到Redis中，以便后续计算帖子分数。</p>
<p>最后，使用CommonUtil.getJsonString方法返回操作结果的json字符串，其中code为0表示操作成功。</p>
<h4 id="功能13：帖子删除"><a href="#功能13：帖子删除" class="headerlink" title="功能13：帖子删除"></a>功能13：帖子删除</h4><h5 id="1-setDelete"><a href="#1-setDelete" class="headerlink" title="1.setDelete"></a>1.setDelete</h5><pre><code class="java">@RequestMapping(path = &quot;/delete&quot;,method = RequestMethod.POST)
    @ResponseBody
    @ApiOperation(value = &quot;删除帖子&quot;)
    public String setDelete(int id)&#123;
        User user = userThreadLocalHolder.getCache();
        if(CommonUtil.isEmtpy(user))&#123;
            return CommonUtil.getJsonString(403,&quot;你还没有登录哦!&quot;);
        &#125;
        // 2 帖子状态删除
        discussPostService.updateStatus(id,2);

        // 触发一次发帖事件，异步同步到es服务器中，使得能够搜索到最新的帖子
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_DELETE)
                .setUserId(user.getId())
                .setEntityType(CommentEntityConstant.ENTITY_TYPE_POST.getType())
                .setEntityId(id);

        eventProducer.handleEvent(event);

        return CommonUtil.getJsonString(0);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，使用@RequestMapping注解指定该方法的访问路径为”&#x2F;delete”，请求方式为POST。该方法用于处理将帖子删除的请求。</p>
<p>然后，使用@ResponseBody注解指定返回值为json字符串。</p>
<p>接着，使用@ApiOperation注解对方法进行描述，说明该方法实现的功能是删除帖子。</p>
<p>然后，通过参数id获取要删除的帖子的id。</p>
<p>接下来，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，如果该用户未登录，则返回登录提示信息。</p>
<p>然后，通过discussPostService的updateStatus方法更新帖子状态为删除状态（status参数值为2）。</p>
<p>接着，创建一个事件event，设置其topic、userId、entityType和entityId属性，并通过eventProducer的handleEvent方法将该事件加入到消息队列中，等待异步处理。</p>
<p>最后，使用CommonUtil.getJsonString方法返回操作结果的json字符串，其中code为0表示操作成功。</p>
<h3 id="CommentController-java"><a href="#CommentController-java" class="headerlink" title="CommentController.java"></a>CommentController.java</h3><h4 id="需要注入的Bean-2"><a href="#需要注入的Bean-2" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">@Autowired
    private CommentService commentService;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    @Autowired
    private RedisTemplate redisTemplate;
</code></pre>
<h4 id="功能14：评论"><a href="#功能14：评论" class="headerlink" title="功能14：评论"></a>功能14：评论</h4><h5 id="1-addComment"><a href="#1-addComment" class="headerlink" title="1.addComment"></a>1.addComment</h5><pre><code class="java">    @LoginRequired
    @RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;,method = RequestMethod.POST)
    public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment)&#123;
        comment.setUserId(userThreadLocalHolder.getCache().getId());
        comment.setStatus(0);
        comment.setCreateTime(new Date());
        commentService.addComment(comment);


        // 触发评论事件
        Event event = new Event().setTopic(MessageConstant.TOPIC_COMMENT)
                .setUserId(userThreadLocalHolder.getCache().getId())
                .setEntityType(comment.getEntityType())
                .setEntityId(comment.getEntityId())
                .setData(&quot;postId&quot;,discussPostId);

        if (comment.getEntityType() == CommentEntityConstant.ENTITY_TYPE_POST.getType()) &#123;
            DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());
            event.setEntityUserId(target.getUserId());
        &#125;else if(comment.getEntityType() == CommentEntityConstant.ENTITY_TYPE_COMMENT.getType())&#123;
            Comment target = commentService.findCommentById(comment.getEntityId());
            event.setEntityUserId(target.getUserId());
        &#125;
        // 异步发送消息至kafka topic
        eventProducer.handleEvent(event);

        if(comment.getEntityType()==CommentEntityConstant.ENTITY_TYPE_POST.getType())&#123;
            event = new Event()
                    .setTopic(MessageConstant.TOPIC_PUBLISH)
                    .setUserId(comment.getUserId())
                    .setEntityType(CommentEntityConstant.ENTITY_TYPE_POST.getType())
                    .setEntityId(discussPostId);
            eventProducer.handleEvent(event);
            // 记录影响帖子分数帖子id
            String postScoreKey = RedisKeyUtil.getPostScoreKey();
            redisTemplate.opsForSet().add(postScoreKey,discussPostId);
        &#125;
        return &quot;redirect:/discuss/detail/&quot; + discussPostId;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>然后，使用@RequestMapping注解指定该方法的访问路径为”&#x2F;add&#x2F;{discussPostId}”，请求方式为POST。该方法用于处理添加评论的请求，其中{discussPostId}表示被评论的帖子id。</p>
<p>然后，通过@PathVariable注解获取被评论的帖子的id。</p>
<p>接下来，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，并将其设置为评论的userId。</p>
<p>然后，设置评论的状态为0（即未被删除），创建时间为当前时间，并调用commentService的addComment方法将评论添加到数据库中。</p>
<p>接着，创建一个事件event，设置其topic、userId、entityType和entityId属性，并根据评论的entityType和entityId添加相应的数据，最后通过eventProducer的handleEvent方法将该事件加入到消息队列中，等待异步处理。</p>
<p>如果评论的entityType为帖子，那么将该事件再次作为发布帖子的事件加入到消息队列中，以便更新该帖子的搜索分数。另外，使用redisTemplate.opsForSet().add方法将该帖子id添加到Redis中，以便后续计算帖子分数。</p>
<p>最后，使用重定向将页面跳转到被评论的帖子详情页。</p>
<h3 id="DataController-java"><a href="#DataController-java" class="headerlink" title="DataController.java"></a>DataController.java</h3><h4 id="需要注入的Bean-3"><a href="#需要注入的Bean-3" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java"> @Autowired
    private DataService dataService;
</code></pre>
<h4 id="功能15：网站数据统计"><a href="#功能15：网站数据统计" class="headerlink" title="功能15：网站数据统计"></a>功能15：网站数据统计</h4><h5 id="1-getDataPage、getUv、getUau"><a href="#1-getDataPage、getUv、getUau" class="headerlink" title="1.getDataPage、getUv、getUau"></a>1.getDataPage、getUv、getUau</h5><pre><code class="java">/**
     * 数据统计页面
     * @return
     */
    @RequestMapping(path = &quot;/dataViewPage&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)
    public String getDataPage()&#123;
        return &quot;/site/admin/data&quot;;
    &#125;

    /**
     * 统计网站uv
     * @param start
     * @param end
     * @param model
     * @return
     */
    @RequestMapping(path = &quot;/uv&quot;,method = RequestMethod.POST)
    public String getUv(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start,
                        @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date end,
                        Model model)&#123;
        long uv = dataService.calculateUv(start,end);
        model.addAttribute(&quot;uvResult&quot;,uv);
        model.addAttribute(&quot;uvStartDate&quot;,start);
        model.addAttribute(&quot;uvEndDate&quot;,end);
        return &quot;forward:/data/dataViewPage&quot;;
    &#125;

    /**
     * 统计活跃用户
     * @param start
     * @param end
     * @param model
     * @return
     */
    @RequestMapping(path = &quot;/dau&quot;,method = RequestMethod.POST)
    public String getUau(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start,
                        @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)Date end,
                        Model model)&#123;
        long dau = dataService.calculateDau(start,end);
        model.addAttribute(&quot;dauResult&quot;,dau);
        model.addAttribute(&quot;dauStartDate&quot;,start);
        model.addAttribute(&quot;dauEndDate&quot;,end);
        return &quot;forward:/data/dataViewPage&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，定义了一个访问数据统计页面的方法getDataPage，该方法使用@RequestMapping注解指定访问路径为”&#x2F;dataViewPage”，请求方式可以为GET和POST，返回一个字符串”&#x2F;site&#x2F;admin&#x2F;data”，表示跳转到数据统计页。</p>
<p>然后，定义了统计网站访问量的方法getUv，该方法使用@RequestMapping注解指定访问路径为”&#x2F;uv”，请求方式为POST。使用@DateTimeFormat注解将传入的日期字符串格式化为Date类型的start和end参数。调用dataService的calculateUv方法计算start-end期间的网站访问量，并将结果存入模型（Model）中的uvResult属性，并将start和end也存入模型中，最后通过forward方式将请求转发到getDataPage方法进行处理。</p>
<p>接着，定义了统计活跃用户数的方法getUau，该方法使用@RequestMapping注解指定访问路径为”&#x2F;dau”，请求方式为POST。同样使用@DateTimeFormat注解将传入的日期字符串格式化为Date类型的start和end参数。调用dataService的calculateDau方法计算start-end期间的活跃用户数，并将结果存入模型（Model）中的dauResult属性，并将start和end也存入模型中，最后通过forward方式将请求转发到getDataPage方法进行处理。</p>
<p>综上，这段代码通过使用两个POST请求实现了网站访问量和活跃用户数的统计，并将结果展示到数据统计页面中。</p>
<h3 id="FollowController-java"><a href="#FollowController-java" class="headerlink" title="FollowController.java"></a>FollowController.java</h3><h4 id="需要注入的Bean-4"><a href="#需要注入的Bean-4" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">@Autowired
    private FollowService followService;

    @Autowired
    private UserService userService;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;
</code></pre>
<h4 id="功能16：关注以及被关注"><a href="#功能16：关注以及被关注" class="headerlink" title="功能16：关注以及被关注"></a>功能16：关注以及被关注</h4><h5 id="1-toFollow"><a href="#1-toFollow" class="headerlink" title="1.toFollow"></a>1.toFollow</h5><pre><code class="java"> @RequestMapping(path = &quot;/toFollow&quot;,method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    @ApiOperation(value = &quot;关注&quot;)
    public String toFollow(int entityType,int entityId)&#123;
        User user = userThreadLocalHolder.getCache();
        followService.toFollow(user.getId(),entityType,entityId);
        // 触发关注事件
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_FOLLOW)
                .setEntityType(entityType)
                .setEntityId(entityId)
                .setEntityUserId(entityId)
                .setUserId(entityId);
        eventProducer.handleEvent(event);
        return CommonUtil.getJsonString(0,&quot;已关注&quot;);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;toFollow”，请求方式为POST。其中entityType表示被关注的实体类型，entityId表示被关注的实体id。</p>
<p>然后，使用@ResponseBody注解将方法返回值转化为JSON格式串。</p>
<p>接着，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>然后，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，并使用followService的toFollow方法将该用户对该实体进行关注。</p>
<p>接下来，创建一个事件event，设置其topic、entityType、entityId、entityUserId和userId属性，并调用eventProducer的handleEvent方法将该事件加入到消息队列中，等待异步处理。</p>
<p>最后，使用CommonUtil.getJsonString方法将结果封装为JSON格式串并返回给前端。如果成功关注，则code为0，msg为”已关注”；如果失败，则code为1，msg为”关注失败”。</p>
<h5 id="2-unFollow"><a href="#2-unFollow" class="headerlink" title="2.unFollow"></a>2.unFollow</h5><pre><code class="java">
@RequestMapping(path = &quot;/unFollow&quot;,method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    @ApiOperation(value = &quot;取消关注&quot;)
    public String unFollow(int entityType,int entityId)&#123;
        User user = userThreadLocalHolder.getCache();
        followService.unFollow(user.getId(),entityType,entityId);
        return CommonUtil.getJsonString(0,&quot;已取消关注&quot;);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;unFollow”，请求方式为POST。其中entityType表示被取消关注的实体类型，entityId表示被取消关注的实体id。</p>
<p>然后，使用@ResponseBody注解将方法返回值转化为JSON格式串。</p>
<p>接着，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>然后，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，并使用followService的unFollow方法将该用户对该实体进行取消关注。</p>
<p>最后，使用CommonUtil.getJsonString方法将结果封装为JSON格式串并返回给前端。如果成功取消关注，则code为0，msg为”已取消关注”；如果失败，则code为1，msg为”取消关注失败”。</p>
<h5 id="3-getfollowees"><a href="#3-getfollowees" class="headerlink" title="3.getfollowees"></a>3.getfollowees</h5><pre><code class="java">    @RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;,method = RequestMethod.GET)
    @LoginRequired
    public String getfollowees(@PathVariable(&quot;userId&quot;) int userId, PageInfo pageInfo, Model model)&#123;
        User user = userService.findUserById(userId);
        if(CommonUtil.isEmtpy(user))&#123;
            throw new RuntimeException(&quot;该用户不存在&quot;);
        &#125;
        model.addAttribute(&quot;user&quot;,user);

        // 设置分页
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/followees/&quot; + userId);
        pageInfo.setRows((int) followService.findFolloweeCount(userId, CommentEntityConstant.ENTITY_TYPE_USER.getType()));

        // 封装视图层数据
        List&lt;Map&lt;String,Object&gt;&gt; userList = followService.findFollowees(userId,pageInfo.getOffset(),pageInfo.getLimit());
        if(!CommonUtil.isEmtpy(userList))&#123;
            for (Map&lt;String,Object&gt; map:userList) &#123;
                User u = (User) map.get(&quot;user&quot;);
                map.put(&quot;hasFollowed&quot;,hasFollowed(u.getId()));
            &#125;
        &#125;
        model.addAttribute(&quot;userList&quot;,userList);
        return &quot;/site/followee&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>查看某个用户关注的人列表（也即获取关注列表）的功能</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;followees&#x2F;{userId}”，请求方式为GET。其中{userId}表示路径变量，用于指定要查看关注列表的用户id。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过userService的findUserById方法根据userId查找到对应的用户实体。</p>
<p>如果用户不存在，则抛出RuntimeException异常，提示该用户不存在。</p>
<p>接下来，将用户信息添加到model中，以便在前端页面中进行展示。</p>
<p>然后，设置分页参数pageInfo，包括limit、path和rows属性。其中，limit表示每页显示的条数，path表示分页链接的基础路径，rows表示总的数据条数。</p>
<p>接着，使用followService的findFollowees方法获取当前用户关注的人列表，并封装视图层数据到userList中。同时，使用hasFollowed方法判断当前已登录用户是否已经关注了列表中的用户，并将结果放入map的hasFollowed属性中。最后将userList添加到model中，以便在前端页面中进行展示。</p>
<p>最后，返回视图文件路径”&#x2F;site&#x2F;followee”，前端页面将根据该路径渲染出关注列表视图。</p>
<h5 id="4-getfollowers"><a href="#4-getfollowers" class="headerlink" title="4.getfollowers"></a>4.getfollowers</h5><pre><code class="java">@RequestMapping(path = &quot;/followers/&#123;userId&#125;&quot;,method = RequestMethod.GET)
    @LoginRequired
    public String getfollowers(@PathVariable(&quot;userId&quot;) int userId, PageInfo pageInfo, Model model)&#123;
        User user = userService.findUserById(userId);
        if(CommonUtil.isEmtpy(user))&#123;
            throw new RuntimeException(&quot;该用户不存在&quot;);
        &#125;
        model.addAttribute(&quot;user&quot;,user);

        // 设置分页
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/followers/&quot; + userId);
        pageInfo.setRows((int) followService.findFollowerCount(CommentEntityConstant.ENTITY_TYPE_USER.getType(),userId));

        // 封装视图层数据
        List&lt;Map&lt;String,Object&gt;&gt; userList = followService.findFollowers(userId,pageInfo.getOffset(),pageInfo.getLimit());
        if(!CommonUtil.isEmtpy(userList))&#123;
            for (Map&lt;String,Object&gt; map:userList) &#123;
                User u = (User) map.get(&quot;user&quot;);
                map.put(&quot;hasFollowed&quot;,hasFollowed(u.getId()));
            &#125;
        &#125;
        model.addAttribute(&quot;userList&quot;,userList);
        return &quot;/site/follower&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>查看某个用户的粉丝列表（也即获取粉丝列表）的功能，具体来说：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;followers&#x2F;{userId}”，请求方式为GET。其中{userId}表示路径变量，用于指定要查看粉丝列表的用户id。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过userService的findUserById方法根据userId查找到对应的用户实体。</p>
<p>如果用户不存在，则抛出RuntimeException异常，提示该用户不存在。</p>
<p>接下来，将用户信息添加到model中，以便在前端页面中进行展示。</p>
<p>然后，设置分页参数pageInfo，包括limit、path和rows属性。其中，limit表示每页显示的条数，path表示分页链接的基础路径，rows表示总的数据条数。</p>
<p>接着，使用followService的findFollowers方法获取关注当前用户的人列表，并封装视图层数据到userList中。同时，使用hasFollowed方法判断已登录用户是否关注了列表中的用户，并将结果放入map的hasFollowed属性中。最后将userList添加到model中，以便在前端页面中进行展示。</p>
<p>最后，返回视图文件路径”&#x2F;site&#x2F;follower”，前端页面将根据该路径渲染出粉丝列表视图。</p>
<h5 id="5-hasFollowed"><a href="#5-hasFollowed" class="headerlink" title="5.hasFollowed"></a>5.hasFollowed</h5><pre><code class="java">/**
     * 判断当前用户是否关注过用户id为userId的用户
     * @param userId
     * @return true/false
     */
    private boolean hasFollowed(int userId)&#123;
        User user = userThreadLocalHolder.getCache();
        if(CommonUtil.isEmtpy(user))&#123;
            return false;
        &#125;
        return followService.hasFollowed(user.getId(),CommentEntityConstant.ENTITY_TYPE_USER.getType(),userId);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>用户是否关注过某个用户的功能，具体来说：</p>
<p>首先，定义了一个私有方法hasFollowed，用于判断当前已登录用户是否关注了用户ID为userId的用户。</p>
<p>接着，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息，如果当前用户未登录，则返回false。</p>
<p>然后，使用followService的hasFollowed方法判断当前用户是否关注了目标用户。其中，第一个参数表示当前用户id，第二个参数表示关注对象的类型（此处固定为CommentEntityConstant.ENTITY_TYPE_USER.getType()），第三个参数表示要判断的目标用户id。</p>
<p>最后，根据hasFollowed方法的返回值（true&#x2F;false）来判断当前已登录用户是否关注了目标用户。</p>
<h3 id="LikeController-java"><a href="#LikeController-java" class="headerlink" title="LikeController.java"></a>LikeController.java</h3><h4 id="需要注入的Bean-5"><a href="#需要注入的Bean-5" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">  @Autowired
    private LikeService likeService;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;

    @Autowired
    private RedisTemplate redisTemplate;
</code></pre>
<h4 id="功能17：用户点赞"><a href="#功能17：用户点赞" class="headerlink" title="功能17：用户点赞"></a>功能17：用户点赞</h4><h5 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a>1.like</h5><pre><code class="java">@RequestMapping(path = &quot;/giveLike&quot;,method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    @ApiOperation(value = &quot;用户点赞帖子&quot;)
    public String like(int entityType,int entityId,int entityUserId,int postId)&#123;
        User user = userThreadLocalHolder.getCache();

        // 点赞
        likeService.like(user.getId(),entityType,entityId,entityUserId);
        // 数量
        long likeCount = likeService.findEntityLikeCount(entityType,entityId);
        // 状态
        int likeStatus = likeService.findEntityLikeStatus(user.getId(),entityType,entityId);

        // 封装返回结果
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);
        map.put(&quot;likeCount&quot;,likeCount);
        map.put(&quot;likeStatus&quot;,likeStatus);

        // 触发点赞事件
        if (likeStatus == 1) &#123;
            Event event = new Event()
                    .setTopic(MessageConstant.TOPIC_LIKE)
                    .setUserId(userThreadLocalHolder.getCache().getId())
                    .setEntityType(entityType)
                    .setEntityId(entityId)
                    .setEntityUserId(entityUserId)
                    .setData(&quot;postId&quot;,postId);
            eventProducer.handleEvent(event);
        &#125;

        if (entityType == CommentEntityConstant.ENTITY_TYPE_POST.getType())&#123;
            // 记录影响帖子分数帖子id
            String postScoreKey = RedisKeyUtil.getPostScoreKey();
            redisTemplate.opsForSet().add(postScoreKey,postId);
        &#125;

        return CommonUtil.getJsonString(0,null,map);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>用户对帖子进行点赞的功能，具体来说：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;giveLike”，请求方式为POST。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息。</p>
<p>然后，调用likeService的like方法对目标实体进行点赞，其中，第一个参数表示点赞用户id，第二个参数表示点赞对象类型，第三个参数表示点赞对象id，第四个参数表示点赞对象所属用户id。</p>
<p>接下来，分别调用likeService的findEntityLikeCount和findEntityLikeStatus方法获取点赞数和当前用户是否已点赞的状态。</p>
<p>接着，封装点赞数量和点赞状态到map中。</p>
<p>然后，根据点赞状态是否为1来触发点赞事件。如果是，则创建一个事件对象event，并设置topic、userId、entityType、entityId、entityUserId和data属性，接着调用eventProducer的handleEvent方法来处理该事件。</p>
<p>最后，如果点赞对象类型为CommentEntityConstant.ENTITY_TYPE_POST，即点赞的是帖子，则记录该帖子的ID到redis数据结构中，以便后续计算帖子热度。</p>
<p>最终，该方法返回一个json字符串，表示点赞结果。其中，0表示成功，null表示错误信息（此处没有返回错误信息），map表示点赞数量和点赞状态。</p>
<h3 id="MessageController-java"><a href="#MessageController-java" class="headerlink" title="MessageController.java"></a>MessageController.java</h3><h4 id="需要注入的Bean-6"><a href="#需要注入的Bean-6" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java"> @Autowired
    private MessageService messageService;

    @Autowired
    private UserService userService;

    @Autowired
    private ThreadLocalHolder&lt;User&gt; userThreadLocalHolder;
</code></pre>
<h4 id="功能18：消息通知以及私信"><a href="#功能18：消息通知以及私信" class="headerlink" title="功能18：消息通知以及私信"></a>功能18：消息通知以及私信</h4><h5 id="1-getLetterList"><a href="#1-getLetterList" class="headerlink" title="1.getLetterList"></a>1.getLetterList</h5><pre><code class="java">@RequestMapping(path = &quot;/letter/list&quot;, method = RequestMethod.GET)
    @LoginRequired
    public String getLetterList(Model model, PageInfo pageInfo) &#123;
        //获取登录用户信息
        User user = userThreadLocalHolder.getCache();

        //设置分页信息
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/message/letter/list&quot;);
        pageInfo.setRows(messageService.findConversationCount(user.getId()));

        // 查询会话列表
        List&lt;Message&gt; conversationList = messageService.findConversations(user.getId(), pageInfo.getOffset(), pageInfo.getLimit());
        // 封装数据
        List&lt;Map&lt;String, Object&gt;&gt; conversations = new ArrayList&lt;&gt;();
        if (!CommonUtil.isEmtpy(conversationList)) &#123;
            for (Message message : conversationList) &#123;
                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
                map.put(&quot;conversation&quot;, message);
                map.put(&quot;letterCount&quot;, messageService.findLetterCount(message.getConversationId()));
                map.put(&quot;unreadCount&quot;, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));
                int targetId = user.getId() == message.getFromId() ? message.getToId() : message.getFromId();
                map.put(&quot;target&quot;, userService.findUserById(targetId));
                conversations.add(map);
            &#125;
        &#125;
        model.addAttribute(&quot;conversations&quot;, conversations);

        //查询未读消息总数
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
        model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);
        int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);
        model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);
        return &quot;/site/letter&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>获取用户私信列表的功能，具体来说：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;letter&#x2F;list”，请求方式为GET。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过userThreadLocalHolder.getCache()方法获取当前已登录用户的信息。</p>
<p>然后，设置分页信息，包括每页显示数量、请求路径和总记录数，其中，每页显示数量固定为5，请求路径为”&#x2F;message&#x2F;letter&#x2F;list”，总记录数通过调用messageService的findConversationCount方法查询得到。</p>
<p>接下来，调用messageService的findConversations方法查询会话列表，其中，第一个参数表示当前用户id，第二个参数表示limit子句中的offset，第三个参数表示每页显示数量。</p>
<p>然后，封装会话列表数据到List&lt;Map&lt;String, Object&gt;&gt; conversations中，包括会话信息、私信数量、未读私信数量和对方用户信息。其中，会话信息通过map.put(“conversation”, message)封装，私信数量通过map.put(“letterCount”, messageService.findLetterCount(message.getConversationId()))封装，未读私信数量通过map.put(“unreadCount”, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()))封装，对方用户信息通过map.put(“target”, userService.findUserById(targetId))封装。</p>
<p>接着，将conversations添加到model中。</p>
<p>然后，通过调用messageService的findLetterUnreadCount方法获取用户未读私信数量，将其添加到model中。</p>
<p>最后，通过调用messageService的findNoticeUnreadCount方法获取用户未读系统消息数量，将其添加到model中。</p>
<p>最终，该方法返回一个字符串，表示私信页面视图的路径，即”&#x2F;site&#x2F;letter”。</p>
<h5 id="2-getLetterDetail"><a href="#2-getLetterDetail" class="headerlink" title="2.getLetterDetail"></a>2.getLetterDetail</h5><pre><code>@RequestMapping(path = &quot;/letter/detail/&#123;conversationId&#125;&quot;, method = RequestMethod.GET)
    @LoginRequired
    public String getLetterDetail(@PathVariable(&quot;conversationId&quot;) String conversationId, Model model, PageInfo pageInfo) &#123;
        // 设置分页信息
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/message/letter/detail/&quot; + conversationId);
        pageInfo.setRows(messageService.findLetterCount(conversationId));

        // 得到私信列表
        List&lt;Message&gt; letterList = messageService.findLetters(conversationId, pageInfo.getOffset(), pageInfo.getLimit());

        // 封装页面数据
        List&lt;Map&lt;String, Object&gt;&gt; letters = new ArrayList&lt;&gt;();
        if (!CommonUtil.isEmtpy(letterList)) &#123;
            for (Message message : letterList) &#123;
                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
                map.put(&quot;letter&quot;, message);
                map.put(&quot;fromUser&quot;, userService.findUserById(message.getFromId()));
                letters.add(map);
            &#125;
        &#125;

        model.addAttribute(&quot;letters&quot;, letters);

        // 获取私信目标
        model.addAttribute(&quot;target&quot;, getLetterTarget(conversationId));

        // 将所有未读消息设置为已读状态
        List&lt;Integer&gt; letterIds = getLetterIds(letterList);
        if (!CommonUtil.isEmtpy(letterIds)) &#123;
            messageService.readMessage(letterIds);
        &#125;

        return &quot;/site/letter-detail&quot;;

    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<h5 id="3-getLetterIds"><a href="#3-getLetterIds" class="headerlink" title="3.getLetterIds"></a>3.getLetterIds</h5><pre><code>/**
     * 得到集合私信列表中未读消息的id
     *
     * @param letterList
     * @return
     */
    private List&lt;Integer&gt; getLetterIds(List&lt;Message&gt; letterList) &#123;
        List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();
        if (!CommonUtil.isEmtpy(letterList)) &#123;
            for (Message message : letterList) &#123;
                // 以接收者身份读取未读消息
                if (message.getToId() == userThreadLocalHolder.getCache().getId() &amp;&amp; message.getStatus() == 0) &#123;
                    ids.add(message.getId());
                &#125;
            &#125;
        &#125;
        return ids;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>获取私信详情的功能，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;letter&#x2F;detail&#x2F;{conversationId}”，请求方式为GET。其中，@PathVariable注解表示将路径中的{conversationId}值绑定到参数conversationId上。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过调用messageService的findLetterCount方法获取指定会话ID的私信数量，并将分页信息设置到pageInfo对象中，包括每页显示数量、分页路径和总记录数。</p>
<p>然后，通过调用messageService的findLetters方法查询指定会话ID的私信列表，其中，第一个参数表示会话ID，第二个参数表示limit子句中的offset，第三个参数表示每页显示数量。</p>
<p>接下来，将查询到的私信列表数据封装到List&lt;Map&lt;String, Object&gt;&gt; letters中，包括私信信息和发送者用户信息。具体实现是通过一个for循环遍历该会话ID下的所有私信，然后将私信信息和发送者用户信息封装到一个Map中，并将该Map添加到letters列表中。</p>
<p>接着，将封装好的私信列表数据传递到model中。</p>
<p>然后，通过编写getLetterTarget方法获取私信目标，即与当前用户进行私信交流的用户信息，该函数的实现可以根据需要自行编写。</p>
<p>接下来，调用getLetterIds方法获取私信列表中所有未读私信的ID列表，然后通过调用messageService的readMessage方法将未读私信设置为已读状态。</p>
<p>最后，该方法返回一个字符串，表示私信详情页面视图的路径，即”&#x2F;site&#x2F;letter-detail”。</p>
<h5 id="4-getLetterTarget"><a href="#4-getLetterTarget" class="headerlink" title="4.getLetterTarget"></a>4.getLetterTarget</h5><pre><code>
  /**
     * 根据会话id获取私信接收人信息
     *
     * @param conversationId
     * @return
     */
    private User getLetterTarget(String conversationId) &#123;
        String[] ids = conversationId.split(&quot;_&quot;);
        int d0 = Integer.parseInt(ids[0]);
        int d1 = Integer.parseInt(ids[1]);

        if (userThreadLocalHolder.getCache().getId() == d0) &#123;
            return userService.findUserById(d1);
        &#125; else &#123;
            return userService.findUserById(d0);
        &#125;
    &#125;
</code></pre>
<p>获取私信目标的功能，即根据会话ID获取另一个与当前用户进行私信交流的用户信息。具体实现流程如下：</p>
<p>首先，定义一个私有方法getLetterTarget，该方法接收一个表示会话ID的字符串参数conversationId，并返回一个User对象。</p>
<p>然后，通过使用String类的split方法将conversationId字符串以”_”为分隔符切割成两个部分，保存到ids数组中。</p>
<p>接着，将数组中第一个元素d0和第二个元素d1转换成整数类型，并进行比较。如果当前用户的ID等于d0，则表示私信的接收人是d1（即与当前用户进行私信交流的用户），否则私信的接收人是d0（即当前用户正在与其进行私信交流）。</p>
<p>最后，通过userService的findUserById方法根据接收人ID获取接收人信息，并将获取到的User对象作为结果返回。</p>
<p>总体来说，该方法的主要作用是通过解析会话ID来确定私信接收者的ID，然后通过该ID获取私信接收者的详细信息，并将结果封装到一个User对象中返回。</p>
<h5 id="5-sendLetter"><a href="#5-sendLetter" class="headerlink" title="5.sendLetter"></a>5.sendLetter</h5><pre><code>@RequestMapping(path = &quot;/letter/send&quot;, method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    @ApiOperation(value = &quot;发送私信&quot;)
    public String sendLetter(String toName, String content) &#123;
        User target = userService.findUserByUserName(toName);
        if (CommonUtil.isEmtpy(target)) &#123;
            return CommonUtil.getJsonString(1, &quot;目标用户不存在&quot;);
        &#125;

        // 构造私信消息对象
        Message message = new Message();
        message.setFromId(userThreadLocalHolder.getCache().getId());
        message.setToId(target.getId());
        // 会话id生成规则：小的用户id在下划线前，大的用户id在下划线后
        if (message.getFromId() &lt; message.getToId()) &#123;
            message.setConversationId(message.getFromId() + &quot;_&quot; + message.getToId());
        &#125; else &#123;
            message.setConversationId(message.getToId() + &quot;_&quot; + message.getFromId());
        &#125;
        message.setContent(content);
        message.setCreateTime(new Date());

        // 执行插入操作
        messageService.addMessage(message);

        return CommonUtil.getJsonString(0);

    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>发送私信的功能，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;letter&#x2F;send”，请求方式为POST。其中，@ResponseBody注解表示该方法返回一个Json格式的字符串。</p>
<p>然后，使用@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>接着，通过调用userService的findUserByUserName方法获取目标用户名对应的用户信息，并将结果保存到target对象中。如果目标用户不存在，则返回一个Json字符串，表示目标用户不存在。</p>
<p>然后，根据当前用户ID和目标用户ID，构造一个会话ID并将其设置到message对象中。</p>
<p>接着，将私信内容、发送时间等信息设置到message对象中，然后通过调用messageService的addMessage方法将消息插入到数据库中。</p>
<p>最后，返回一个Json字符串，表示操作成功。</p>
<p>总体来说，该方法主要作用是构造一个私信消息对象并将其保存到数据库中，让两个用户之间可以进行私信交流</p>
<h5 id="6-getNoticeList"><a href="#6-getNoticeList" class="headerlink" title="6.getNoticeList"></a>6.getNoticeList</h5><pre><code>@RequestMapping(path = &quot;/notice/list&quot;, method = RequestMethod.GET)
    @LoginRequired
    public String getNoticeList(Model model) &#123;
        User user = userThreadLocalHolder.getCache();

        // 查询评论类通知
        Message latestCommentNotice = messageService.findLatestNotice(user.getId(), MessageConstant.TOPIC_COMMENT);
        Map&lt;String, Object&gt; latestCommentNoticeVo = getNotice(latestCommentNotice, user,MessageConstant.TOPIC_COMMENT);
        if (!CommonUtil.isEmtpy(latestCommentNoticeVo)) &#123;
            model.addAttribute(&quot;commentNotice&quot;, latestCommentNoticeVo);
        &#125;

        // 查询点赞类的通知
        Message latestLikeNotice = messageService.findLatestNotice(user.getId(), MessageConstant.TOPIC_LIKE);
        Map&lt;String, Object&gt; latestLikeNoticeVo = getNotice(latestLikeNotice, user,MessageConstant.TOPIC_LIKE);
        if (!CommonUtil.isEmtpy(latestLikeNoticeVo)) &#123;
            model.addAttribute(&quot;likeNotice&quot;, latestLikeNoticeVo);
        &#125;

        // 查询关注类的通知
        Message latestFollowNotice = messageService.findLatestNotice(user.getId(), MessageConstant.TOPIC_FOLLOW);
        Map&lt;String, Object&gt; latestFollowNoticeVo = getNotice(latestFollowNotice, user,MessageConstant.TOPIC_FOLLOW);
        if (!CommonUtil.isEmtpy(latestFollowNoticeVo)) &#123;
            model.addAttribute(&quot;followNotice&quot;, latestFollowNoticeVo);
        &#125;

        // 查询未读消息数量
        int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);
        model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
        model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);

        return &quot;/site/notice&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>获取通知列表的功能，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;notice&#x2F;list”，请求方式为GET。其中，@LoginRequired注解表示该方法需要登录才能操作。</p>
<p>然后，通过调用userThreadLocalHolder的getCache方法获取当前用户的信息，并保存到user对象中。</p>
<p>接着，通过调用messageService的findLatestNotice方法分别查询评论类、点赞类和关注类的最新通知，并将结果保存到latestCommentNotice、latestLikeNotice和latestFollowNotice对象中。</p>
<p>然后，分别通过调用getNotice方法将查询到的通知对象转换成Map&lt;String, Object&gt;格式的数据，并将其放入model中，以便在前端页面进行展示。</p>
<p>最后，通过调用messageService的findNoticeUnreadCount和findLetterUnreadCount方法查询未读消息数量，并将其保存到model中，以便在前端页面进行展示。</p>
<p>总体来说，该方法主要作用是查询当前用户的通知列表以及未读消息数量，并将结果封装到Model对象中返回给前端页面进行展示。</p>
<h5 id="7-getNotice"><a href="#7-getNotice" class="headerlink" title="7.getNotice"></a>7.getNotice</h5><pre><code>/**
     * 封装系统通知
     * @param notice
     * @param user
     * @param topic
     * @return
     */
    private Map&lt;String, Object&gt; getNotice(Message notice, User user,String topic) &#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
        if (!CommonUtil.isEmtpy(notice)) &#123;
            map.put(&quot;message&quot;, notice);
            String content = HtmlUtils.htmlUnescape(notice.getContent());
            HashMap data = JSONObject.parseObject(content, HashMap.class);
            map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));
            map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));
            map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));

            int count = messageService.findNoticeCount(user.getId(), topic);
            map.put(&quot;count&quot;, count);
            int unread = messageService.findNoticeUnreadCount(user.getId(), topic);
            map.put(&quot;unread&quot;, unread);
        &#125;
        return map;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>私有方法，主要作用是将Message对象封装为Map&lt;String, Object&gt;格式的数据，以便在前端页面进行展示，具体实现流程如下：</p>
<p>首先，定义一个名为map的HashMap对象，并设置其初始容量为10。</p>
<p>然后，根据传入的notice对象判断其是否为空。如果不为空，则将其保存到map中，并对通知内容进行解码处理。</p>
<p>接着，通过调用JSONObject的parseObject方法将通知内容转换成HashMap格式的数据，并将其中的用户ID、实体类型和实体ID进行记录。</p>
<p>然后，通过调用userService的findUserById方法获取对应用户ID的用户信息，并将其保存到map中。</p>
<p>接下来，将实体类型和实体ID也保存到map中，并通过调用messageService的findNoticeCount和findNoticeUnreadCount方法查询当前用户在该主题下的通知总数和未读数量，并将结果也保存到map中。</p>
<p>最后，返回map对象。</p>
<p>总体来说，该方法主要作用是将Message对象中的信息提取出来，并将其封装为Map&lt;String, Object&gt;格式的数据以便在前端页面进行展示。</p>
<h5 id="8-getNoticeDetail"><a href="#8-getNoticeDetail" class="headerlink" title="8.getNoticeDetail"></a>8.getNoticeDetail</h5><pre><code> @RequestMapping(path = &quot;/notice/detail/&#123;topic&#125;&quot;, method = RequestMethod.GET)
    @LoginRequired
    public String getNoticeDetail(Model model, PageInfo pageInfo, @PathVariable(&quot;topic&quot;) String topic) &#123;
        // 获取当前用户信息
        User user = userThreadLocalHolder.getCache();

        // 设置分页信息
        pageInfo.setLimit(5);
        pageInfo.setPath(&quot;/message/notice/detail/&quot; + topic);
        pageInfo.setRows(messageService.findNoticeCount(user.getId(), topic));

        // 查询通知消息列表
        List&lt;Message&gt; noticeList = messageService.findNoticeList(user.getId(), topic, pageInfo.getOffset(), pageInfo.getLimit());
        List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = new ArrayList&lt;&gt;();
        if (!CommonUtil.isEmtpy(noticeList)) &#123;
            for (Message notice : noticeList) &#123;
                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
                // 通知
                map.put(&quot;notice&quot;, notice);

                // 内容
                String content = HtmlUtils.htmlUnescape(notice.getContent());
                JSONObject data = JSONObject.parseObject(content);
                map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));
                map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));
                map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));
                map.put(&quot;postId&quot;, data.get(&quot;postId&quot;));

                // 通知作者
                map.put(&quot;fromUser&quot;, userService.findUserById(notice.getFromId()));
                noticeVoList.add(map);
            &#125;
        &#125;

        model.addAttribute(&quot;notices&quot;, noticeVoList);

        //设置已读
        List&lt;Integer&gt; ids = getLetterIds(noticeList);
        if (!ids.isEmpty()) &#123;
            messageService.readMessage(ids);
        &#125;

        return &quot;/site/notice-detail&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>消息通知详情页面的后端控制器方法，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;notice&#x2F;detail&#x2F;{topic}”，请求方式为GET。其中，@LoginRequired注解表示该方法需要登录才能操作，@PathVariable注解表示从URL路径中获取topic参数。</p>
<p>然后，通过调用userThreadLocalHolder的getCache方法获取当前用户的信息，并保存到user对象中。</p>
<p>接着，设置分页信息并查询通知消息列表。通过调用messageService的findNoticeCount、findNoticeList和findLetterIds方法分别查询消息总数、分页后的消息列表和未读消息ID列表，并将结果保存到pageInfo、noticeList和ids对象中。</p>
<p>然后，通过遍历noticeList中的每个Message对象，将其封装为Map&lt;String, Object&gt;格式的数据，并将其添加到noticeVoList中，以便在前端页面进行展示。其中，提取了通知、内容、通知作者等信息，并使用userService的findUserById方法获取对应用户ID的用户信息。同时，对于不同类型的实体还提取了其实体类型、实体ID和帖子ID等信息。</p>
<p>接下来，通过调用model的addAttribute方法将noticeVoList保存到Model对象中，以便在前端页面进行展示。</p>
<p>然后，调用getLetterIds方法获取未读消息ID列表，并通过调用messageService的readMessage方法将其标记为已读。</p>
<p>最后，返回对应的前端页面地址。</p>
<p>总体来说，该方法主要作用是查询当前用户在指定主题下的通知消息列表，并将其封装为Map&lt;String, Object&gt;格式的数据以便在前端页面进行展示。同时，也会将未读消息标记为已读。</p>
<h3 id="SearchController-java"><a href="#SearchController-java" class="headerlink" title="SearchController.java"></a>SearchController.java</h3><h4 id="需要注入的Bean-7"><a href="#需要注入的Bean-7" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">@Autowired
    private ElasticsearchService elasticsearchService;

    @Autowired
    private UserService userService;

    @Autowired
    private LikeService likeService;
</code></pre>
<h4 id="功能19：搜索"><a href="#功能19：搜索" class="headerlink" title="功能19：搜索"></a>功能19：搜索</h4><h5 id="1-search"><a href="#1-search" class="headerlink" title="1.search"></a>1.search</h5><pre><code class="java">/**
     * 搜索方法
     *      提交方式为get,提交路径/search/search_kw?keyword=xxx
     * @param keyword
     * @param pageInfo
     * @param model
     * @return
     */
    @RequestMapping(value = &quot;/search_kw&quot;,method = RequestMethod.GET)
    public String search(String keyword, PageInfo pageInfo, Model model)&#123;

        // 搜索帖子
        Page&lt;DiscussPost&gt; searchResultPage = elasticsearchService.searchDiscussPostByCondition(keyword, pageInfo.getCurrent() - 1, pageInfo.getLimit());

        // 聚合数据，封装数据
        List&lt;Map&lt;String,Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();
        if(!CommonUtil.isEmtpy(searchResultPage))&#123;
            for (DiscussPost discussPost : searchResultPage) &#123;
                Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(16);
                // 帖子数据
                map.put(&quot;post&quot;,discussPost);
                // 用户数据
                map.put(&quot;user&quot;,userService.findUserById(discussPost.getUserId()));
                // 帖子点赞数据
                map.put(&quot;likeCount&quot;,likeService.findEntityLikeCount(CommentEntityConstant.ENTITY_TYPE_POST.getType(),discussPost.getId()));
                discussPosts.add(map);
            &#125;
        &#125;

        // 传入作用域数据给页面模板
        model.addAttribute(&quot;discussPosts&quot;,discussPosts);
        model.addAttribute(&quot;keyword&quot;,keyword);

        //设置分页信息
        pageInfo.setPath(&quot;/search/search_kw?keyword=&quot; + keyword);
        pageInfo.setRows(searchResultPage==null?0: (int) searchResultPage.getTotalElements());
        return &quot;/site/search&quot;;
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<h3 id="ShareController-java"><a href="#ShareController-java" class="headerlink" title="ShareController.java"></a>ShareController.java</h3><h4 id="需要注入的Bean-8"><a href="#需要注入的Bean-8" class="headerlink" title="需要注入的Bean"></a>需要注入的Bean</h4><pre><code class="java">/**
     * 生成图片时间比较长，一定是异步方式，最好使用事件驱动方式（分享事件）实现，controller-&gt;kafka 异步实现即可
     */
    @Autowired
    private EventProducer eventProducer;

    @Value(&quot;$&#123;community.path.domain&#125;&quot;)
    private String domain;

    @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)
    private String contextPath;

    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)
    private String wkImageStorage;

    @Value(&quot;$&#123;qiniu.bucket.share.url&#125;&quot;)
    private String shareBucketUrl;
</code></pre>
<h4 id="功能20：分享长图"><a href="#功能20：分享长图" class="headerlink" title="功能20：分享长图"></a>功能20：分享长图</h4><h5 id="1-share"><a href="#1-share" class="headerlink" title="1.share"></a>1.share</h5><pre><code>@RequestMapping(path = &quot;/shareImage&quot;,method = RequestMethod.GET)
    @ResponseBody
    @ApiOperation(value = &quot;分享长图&quot;)
    public String share(String htmlUrl)&#123;
        // 文件名
        String fileName = CommonUtil.generateUUID();

        // 构建kafka event,异步生成长图
        Event event = new Event()
                .setTopic(MessageConstant.TOPIC_SHARE)
                .setData(&quot;htmlUrl&quot;,htmlUrl)
                .setData(&quot;fileName&quot;,fileName)
                .setData(&quot;suffix&quot;,&quot;.png&quot;);

        eventProducer.handleEvent(event);

        // 返回访问路径
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);
//        String url = domain + contextPath + &quot;/share/image/&quot; + fileName;
        map.put(&quot;shareUrl&quot;,shareBucketUrl + &quot;/&quot; + fileName);


        return CommonUtil.getJsonString(0,null,map);
    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>网站中的”分享长图”功能的后端控制器方法，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;shareImage”，请求方式为GET。其中，传入的参数为htmlUrl。</p>
<p>然后，根据生成的UUID作为文件名fileName，构建一个kafka事件Event，并设置其主题为MessageConstant.TOPIC_SHARE，数据包括htmlUrl、fileName和suffix(后缀名为”.png”)等信息。</p>
<p>接着，通过调用eventProducer的handleEvent方法将事件发送到kafka服务器，异步生成长图。</p>
<p>然后，返回访问路径。通过将shareBucketUrl和fileName拼接在一起，生成长图在对象存储中的访问路径。并将其保存在Map&lt;String, Object&gt;格式的map中。</p>
<p>最后，通过调用CommonUtil的getJsonString方法将map封装为JSON格式的字符串，并返回给前端页面。</p>
<p>总体来说，该方法主要作用是异步生成一个长图，并返回其在对象存储中的访问路径。同时，也将该访问路径封装为JSON格式的字符串返回给前端页面，以供用户进行操作。</p>
<h5 id="2-getShareImage-已废弃"><a href="#2-getShareImage-已废弃" class="headerlink" title="2.getShareImage(已废弃)"></a>2.getShareImage(已废弃)</h5><pre><code class="java">@RequestMapping(path = &quot;/image/&#123;fileName&#125;&quot;,method = RequestMethod.GET)
    @Deprecated
    public void getShareImage(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response)&#123;
        if (StringUtils.isBlank(fileName))&#123;
            throw new IllegalArgumentException(&quot;文件名不能为空&quot;);
        &#125;

        response.setContentType(&quot;image/png&quot;);
        File file = new File(wkImageStorage + &quot;/&quot; + fileName + &quot;.png&quot;);
        try &#123;
            ServletOutputStream os = response.getOutputStream();
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[1024];
            int offset = 0;
            while ((offset=fis.read(buffer))!=-1) &#123;
                os.write(buffer);
            &#125;
        &#125; catch (IOException e) &#123;
            log.error(&quot;获取长图失败:&quot;+e.getMessage());
        &#125;

    &#125;
</code></pre>
<p><strong>思路：</strong></p>
<p>获取分享长图的后端控制器方法，具体实现流程如下：</p>
<p>首先，使用@RequestMapping注解指定访问路径为”&#x2F;image&#x2F;{fileName}”，请求方式为GET。其中，传入的参数为fileName。</p>
<p>然后，判断文件名是否为空，如果为空，则抛出IllegalArgumentException异常。</p>
<p>接着，设置response的ContentType为”image&#x2F;png”，即返回的数据类型为PNG格式的图片。并根据fileName从本地磁盘中读取对应的长图文件。</p>
<p>最后，通过调用response的getOutputStream方法和FileInputStream的read方法，将读取到的数据以字节流的形式写入到response的输出流中，并返回给客户端。</p>
<p>总体来说，该方法主要作用是获取分享长图并将其以PNG格式的图片数据流的形式返回给客户端。在前端页面中，用户可以在该图片上进行保存、分享等操作。但是需要注意的是，此方法已被标记为@Deprecated，即已过时。在实际的开发中，建议使用对象存储等第三方工具来存储和管理图片资源。</p>
<h3 id="SensitiveWordFilter-java"><a href="#SensitiveWordFilter-java" class="headerlink" title="SensitiveWordFilter.java"></a>SensitiveWordFilter.java</h3><h4 id="功能4：-通过前缀树实现过滤敏感词功能"><a href="#功能4：-通过前缀树实现过滤敏感词功能" class="headerlink" title="功能4： 通过前缀树实现过滤敏感词功能"></a>功能4： 通过前缀树实现过滤敏感词功能</h4><p>​		详情见其它分类中敏感词过滤类。</p>
<h2 id="11-可能的面试题"><a href="#11-可能的面试题" class="headerlink" title="11.可能的面试题"></a>11.可能的面试题</h2><h4 id="1-什么是DAO"><a href="#1-什么是DAO" class="headerlink" title="1.什么是DAO"></a>1.什么是DAO</h4><p>data access object，存放数据库访问对象。</p>
<h4 id="2-Spring-MVC是什么，是怎样的工作流程"><a href="#2-Spring-MVC是什么，是怎样的工作流程" class="headerlink" title="2.Spring MVC是什么，是怎样的工作流程"></a>2.Spring MVC是什么，是怎样的工作流程</h4><p>服务器分为表现层&#x2F;业务层&#x2F;数据层，其中Spring MVC是工作在表现层，作用是接收&#x2F;解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。</p>
<ol>
<li>客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)</li>
<li>DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler。</li>
<li>查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理</li>
<li>HandlerAdapter根据Handler来调用真正的Controller</li>
<li>Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View</li>
<li>ViewResolver根据逻辑view找到实际view</li>
<li>DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者</li>
</ol>
<ul>
<li>C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。</li>
<li>M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。</li>
<li>V - View：视图。返回给客户看的结果。</li>
</ul>
<h4 id="怎么实现注册功能的？"><a href="#怎么实现注册功能的？" class="headerlink" title="怎么实现注册功能的？"></a>怎么实现<strong>注册功能</strong>的？</h4><p>根据请求来拆解功能<br>1，打开注册网页<br>2，把注册的信息发送给服务器（点注册）<br>3，把激活邮件发送给邮箱<br>4，利用激活链接打开网页</p>
<p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p>
<h4 id="什么是Interceptor，在项目的哪里使用到了Interceptor"><a href="#什么是Interceptor，在项目的哪里使用到了Interceptor" class="headerlink" title="什么是Interceptor，在项目的哪里使用到了Interceptor?"></a>什么是Interceptor，在项目的哪里使用到了Interceptor?</h4><p>Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查request中的login_ticket，把找到的user信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）</p>
<h4 id="使用什么技术生成验证码"><a href="#使用什么技术生成验证码" class="headerlink" title="使用什么技术生成验证码"></a>使用什么技术生成验证码</h4><p>使用Kaptcha包，可随机生成字符和图片。</p>
<h4 id="如何检查登陆状态"><a href="#如何检查登陆状态" class="headerlink" title="如何检查登陆状态"></a>如何检查登陆状态</h4><p>安全框架解决。</p>
<h4 id="如何实现敏感词过滤"><a href="#如何实现敏感词过滤" class="headerlink" title="如何实现敏感词过滤"></a>如何实现敏感词过滤</h4><p>使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。</p>
<h4 id="什么是Ajax，应用在项目哪些地方？"><a href="#什么是Ajax，应用在项目哪些地方？" class="headerlink" title="什么是Ajax，应用在项目哪些地方？"></a>什么是Ajax，应用在项目哪些地方？</h4><p>ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。<br>项目中：帖子发布成功&#x2F;失败的提示，使用到ajax</p>
<h4 id="什么是事务，事务的四大特性。"><a href="#什么是事务，事务的四大特性。" class="headerlink" title="什么是事务，事务的四大特性。"></a>什么是事务，事务的四大特性。</h4><p>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>ACID：<br>A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。<br>C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。<br>I ：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。<br>D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。</p>
<h4 id="在并发环境下，并发事务会出现哪些问题？"><a href="#在并发环境下，并发事务会出现哪些问题？" class="headerlink" title="在并发环境下，并发事务会出现哪些问题？"></a>在并发环境下，并发事务会出现哪些问题？</h4><ul>
<li>脏读：事务A读到了事务B修改但未提交的数据。</li>
<li>丢失修改：事务A和事务B同时读取了某一数据，并进行减１，此数据最终只会减一。</li>
<li>不可重复读：事务A多次读取某数据时，发现前后不一致（被事务B修改了）</li>
<li>幻读：和不可重复读类似，事务A读取到几行数据，事务B此时插入数据，随后的<strong>查询</strong>中，事务A发现了一些原本不存在的数据。（不是读取）</li>
</ul>
<h4 id="介绍SQL的四个隔离级别"><a href="#介绍SQL的四个隔离级别" class="headerlink" title="介绍SQL的四个隔离级别"></a>介绍SQL的四个隔离级别</h4><ul>
<li>READ-UNCOMMITED(读取未提交）:会出现脏读，不可重复读，幻读。</li>
<li>READ-COMMITED:会出现不可重复读，幻读</li>
<li>REPETABLE-READ:会出现幻读</li>
<li>SERIALIZABLE:都不会出现</li>
</ul>
<h4 id="是怎样实现统一捕获异常的？"><a href="#是怎样实现统一捕获异常的？" class="headerlink" title="是怎样实现统一捕获异常的？"></a>是怎样实现统一捕获异常的？</h4><p>在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。<br>方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。</p>
<h4 id="什么是Redis，Redis有哪些优点？"><a href="#什么是Redis，Redis有哪些优点？" class="headerlink" title="什么是Redis，Redis有哪些优点？"></a>什么是Redis，Redis有哪些优点？</h4><p>概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。<br>优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map&#x2F;guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。</p>
<h4 id="怎么往Spring框架中配置redis，介绍常见的redis操作"><a href="#怎么往Spring框架中配置redis，介绍常见的redis操作" class="headerlink" title="怎么往Spring框架中配置redis，介绍常见的redis操作"></a>怎么往Spring框架中配置redis，介绍常见的redis操作</h4><p><strong>如何配置</strong>：<br>1，导入jar包<br>2，配置端口，以及配置类redisTemplate（注入连接工厂&#x2F;设置序列化方式（json））<br><strong>常见操作</strong><br>Value类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，<br>Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作<br>List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作<br>Set类型：add, size, pop, members等操作<br>Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作<br>操作key：可以delete，以及设置过期时间<br>同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）<br>为什么不包含查询：redis事务就是一系列命令的批量操作，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<h4 id="怎样存储的点赞-x2F-关注-x2F-缓存用户数据"><a href="#怎样存储的点赞-x2F-关注-x2F-缓存用户数据" class="headerlink" title="怎样存储的点赞&#x2F;关注&#x2F;缓存用户数据"></a>怎样存储的点赞&#x2F;关注&#x2F;缓存用户数据</h4><p>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p>
<h4 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h4><p>消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：<br>1，解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。<br>2，异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。<br>3，限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。</p>
<h4 id="消息队列作为信息传递的中间件，需要注意哪些问题？"><a href="#消息队列作为信息传递的中间件，需要注意哪些问题？" class="headerlink" title="消息队列作为信息传递的中间件，需要注意哪些问题？"></a>消息队列作为信息传递的中间件，需要注意哪些问题？</h4><p>1，高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式&#x2F;集群的现成支持）<br>2，数据持久化：防止数据丢失<br>3，如何取数据：消息队列主动通知或者消费者轮询。</p>
<h4 id="Java中的blockingqueue，可以提供线程间的消息队列"><a href="#Java中的blockingqueue，可以提供线程间的消息队列" class="headerlink" title="Java中的blockingqueue，可以提供线程间的消息队列"></a>Java中的blockingqueue，可以提供线程间的消息队列</h4><p>BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）Blocking Queue构建了一个桥梁，能够解决生产速度&#x2F;消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。</p>
<h4 id="什么是Kafka，有哪些功能和应用场景？"><a href="#什么是Kafka，有哪些功能和应用场景？" class="headerlink" title="什么是Kafka，有哪些功能和应用场景？"></a>什么是Kafka，有哪些功能和应用场景？</h4><p>Kafka为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。<br>Kafka主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。</p>
<h4 id="Kafka的消息模型，以及常见术语"><a href="#Kafka的消息模型，以及常见术语" class="headerlink" title="Kafka的消息模型，以及常见术语"></a>Kafka的消息模型，以及常见术语</h4><p>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p>
<h4 id="在项目哪里用到了Kafka"><a href="#在项目哪里用到了Kafka" class="headerlink" title="在项目哪里用到了Kafka"></a>在项目哪里用到了Kafka</h4><p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞&#x2F;评论&#x2F;关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p>
<h4 id="什么是ElasticSearch，存储原理，功能，特点"><a href="#什么是ElasticSearch，存储原理，功能，特点" class="headerlink" title="什么是ElasticSearch，存储原理，功能，特点"></a>什么是ElasticSearch，存储原理，功能，特点</h4><p>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。<br>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行&#x2F;列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication<br>功能：<br>1，分布式的搜索引擎和数据分析引擎<br>2，全文检索，结构化检索，数据分析。<br>3，对海量数据进行近实时的处理<br>特点：<br>1，可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2，不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3，操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p>
<h4 id="项目中哪里使用到了ES-如何使用"><a href="#项目中哪里使用到了ES-如何使用" class="headerlink" title="项目中哪里使用到了ES,如何使用"></a>项目中哪里使用到了ES,如何使用</h4><p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖&#x2F;删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p>
<h4 id="项目中使用到了SpringSecurity在哪些地方？"><a href="#项目中使用到了SpringSecurity在哪些地方？" class="headerlink" title="项目中使用到了SpringSecurity在哪些地方？"></a>项目中使用到了SpringSecurity在哪些地方？</h4><p>重构了用户权限控制（之前用的拦截器）</p>
<h4 id="怎样统计网站UA和DAU"><a href="#怎样统计网站UA和DAU" class="headerlink" title="怎样统计网站UA和DAU"></a>怎样统计网站UA和DAU</h4><p>使用Redis的高级数据结构：<br>HyperLogLog：超级日志，统计独立整数个数。统计UA（独立访问）时，以日期为ｒｅｄｉｓｋｅｙ，将客户端ｉｐ　ａｄｄ到HyperLogLog中（redisTemplate.opsForHyperLogLog().add(redisKey, i);）<br>Bitmap：位图，比如３６５天的签到，只需要３６５／８个字节的大小。统计DAU（日活跃用户）时，以日期为ｒedis　ｋｅｙ，以用户ID作为位（在数据中的位置），用ｏｒ操作，既可以方便的统计一段时间内的注册用户访问人数。</p>
<h4 id="什么是Quartz，特点，专业术语，项目应用"><a href="#什么是Quartz，特点，专业术语，项目应用" class="headerlink" title="什么是Quartz，特点，专业术语，项目应用"></a>什么是Quartz，特点，专业术语，项目应用</h4><p>概念：quartz是一个开源项目，完全基于java实现。是一个优秀的开源调度框架。<br>特点：<br>1，强大的调度功能，例如支持丰富多样的调度方法<br>2，灵活的应用方式，例如支持任务和调度的多种组合方式<br>3，分布式和集群能力<br>专业术语：<br>scheduler：任务调度器 ， scheduler是一个计划调度器容器，容器里面有众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行<br>trigger：触发器，用于定义任务调度时间规则<br>job：任务，即被调度的任务， 主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job<br>misfire：本来应该被执行但实际没有被执行的任务调度<br>项目应用：定时的统计帖子分数（如何设置定时任务和trigger）</p>
<h4 id="什么是Caffeine，如何缓存，项目应用"><a href="#什么是Caffeine，如何缓存，项目应用" class="headerlink" title="什么是Caffeine，如何缓存，项目应用"></a>什么是Caffeine，如何缓存，项目应用</h4><p>概念：Caffeine 是一个基于Java 8的高性能本地缓存框架<br>初始化cache：缓存保存的对象，使用Caffeine.newBuilder()创建，创建时设置缓存大小，过期时间，缓存未命中时的加载方式。<br>为什么只缓存热度帖子？不会经常变。</p>
<h4 id="7-md5原理知道吗？安全吗？可逆吗？"><a href="#7-md5原理知道吗？安全吗？可逆吗？" class="headerlink" title="7.md5原理知道吗？安全吗？可逆吗？"></a>7.md5原理知道吗？安全吗？可逆吗？</h4><p>可以将MD5算法看作一台机器，计算机的任何内容（字符串，图片，视频等）被丢进去都将输出一个长度为128比特的MD5值。</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/d8dd5a76ea6b4e138a98f5b831c8823c.png" alt="img"></p>
<p>输入消息相同，结果也会始终相同，不同的消息，结果则不同。MD5原理简述：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<p>MD5的安全性：普遍认为MD5是很安全，因为暴力破解的时间是一般人无法接受的。实际上如果把用户的密码MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码是比较短的，而且很多用户的密码都使用生日，手机号码，身份证号码，电话号码等等。或者使用常用的一些吉利的数字，或者某个英文单词。如果我把常用的密码先MD5处理，把数据存储起来，然后再跟你的MD5结果匹配，这时我就有可能得到明文。<strong>因此在我们这个项目中，会将用户密码进行加盐处理（密码末尾加随机的字符串）然后再进行MD5加密存入数据库。</strong> </p>
<p> <strong>MD5是否可逆：不可逆，</strong>原因是MD5是一种散列函数，使用的是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>算法，在计算过程中原文的部分信息是丢失了的。</p>
<h4 id="8-项目里哪块用到aop了"><a href="#8-项目里哪块用到aop了" class="headerlink" title="8.项目里哪块用到aop了"></a>8.项目里哪块用到aop了</h4><p>项目中统一处理日志时，用到了AOP。</p>
<h4 id="9-项目中redis怎么用的"><a href="#9-项目中redis怎么用的" class="headerlink" title="9.项目中redis怎么用的"></a>9.项目中redis怎么用的</h4><p>缓存点赞和关注：</p>
<p>1、Redis缓存用户点赞数用String类型，以用户ID为key，点赞时，自增，取消赞时，自减；</p>
<p>缓存实体点赞数，set类型，用户给实体点赞时添加进列表，取消赞时则移除，最后用size统计；</p>
<p>2、缓存粉丝列表，使用zset，存入粉丝的id和关注的时间戳，使用zCard获得粉丝数量。利用reverseRange的时间戳反向排序，按关注时间加载粉丝列表。</p>
<p>优化登录：</p>
<p>1、使用Redis缓存用户信息。将user缓存到Redis中，获取user时，先从Redis获取。取不到时，则从数据库中查询，再缓存到Redis中。因为很多界面都要用到user信息，并发时，频繁的访问数据库，会导致数据库崩溃。变更数据库时，先更新数据库，再清空缓存；</p>
<p>2、使用Redis缓存验证码 。原本添加到session中，减轻服务器压力。将验证码存到Redis中，方便查询检验；</p>
<p>-验证码需要频繁的访问与刷新，对性能要求很高；</p>
<p>-验证码不需要永久存储，通常在很短的时间内就会失效；</p>
<p>-分布式部署时，存在session共享问题；</p>
<p>3、登录凭证：原本添加到MySQL中，为减轻每次登录都去查询数据库的压力，将登录凭证ticket缓存在Redis中，防止每次都要进行数据库的查询，提高并发能力。退出登录时，原本要修改数据库中的登录凭证，现在只需要修改Redis即可。</p>
<h4 id="10-redis的key怎么设计？"><a href="#10-redis的key怎么设计？" class="headerlink" title="10.redis的key怎么设计？"></a>10.redis的key怎么设计？</h4><p>redis的key是String类型的，编写了一个工具类来生成redis的key。key由多个单词拼接而成，中间采用冒号隔开，有的单词是固定的，有些单词是动态的，设计方法如下所示：</p>
<h4 id="12-如何保证redis和数据库一致性？"><a href="#12-如何保证redis和数据库一致性？" class="headerlink" title="12 如何保证redis和数据库一致性？"></a>12 如何保证redis和数据库一致性？</h4><p>项目中只有redis保存用户信息那里才会出现这个问题！！ 因为redis对于点赞、关注、用户凭证和验证码等功能来说都是当作****数据库****来用的，所以没有这个问题。</p>
<p>只要我们使用 Redis 缓存，就必然会面对缓存和数据库间的一致性保证问题，这也算是 Redis 缓存应用中的“必答题”了。最重要的是，如果数据不一致，那么业务应用从缓存中读取的数据就不是最新数据，这会导致严重的错误。比如说，我们把电商商品的库存信息缓存在 Redis 中，如果库存信息不对，那么业务层下单操作就可能出错，这当然是不能接受的。</p>
<p><strong>缓存和数据库的数据不一致是如何发生的？</strong>首先，我们得清楚“数据的一致性”具体是啥意思。其实，这里的“一致性”包含了两种情况：</p>
<ul>
<li>\1. 缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li>
<li>\2. 缓存中本身没有数据，那么，数据库中的值必须是最新值。</li>
</ul>
<ol>
<li>不符合这两种情况的，就属于缓存和数据库的数据不一致问题了。不过，当缓存的读写模式不同时，缓存数据不一致的发生情况不一样，我们的应对方法也会有所不同，所以，我们先按照缓存读写模式，来分别了解下不同模式下的缓存不一致情况。</li>
</ol>
<p>对于<strong>读写缓存</strong>来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p>
<ol>
<li>\1. 同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>
<li>\2. 异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</li>
</ol>
<p>所以，对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<strong>同步直写策略</strong>。不过，需要注意的是，如果采用这种策略，就需要同时更新缓存和数据库。所以，我们要在业务应用中使用事务机制，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直写。当然，在有些场景下，我们对数据一致性的要求可能不是那么高，比如说缓存的是电商商品的非关键属性或者短视频的创建或修改时间等，那么，我们可以使用异步写回策略。</p>
<p>下面我们再来说说只读缓存。对于只读缓存来说，如果有数据新增，会直接写入数据库；而有数据删改时，就需要把只读缓存中的数据标记为无效。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</p>
<p>项目中的redis在存储用户信息时，是只读模式，看代码：</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/d49e7a4f51724a529eb3e4db944f12b4.png" alt="img"> 首先从缓存中取，如果有则直接返回，没有则初始化（从数据库取后存入缓存），然后返回。<img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/87513989323c44349f303083083ab42c.png" alt="img"></p>
<p> 那么只读情况下，这个过程中会不会出现数据不一致的情况呢？考虑到新增数据和删改数据的情况不一样，所以我们分开来看。</p>
<p>如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，此时，缓存和数据库的数据是一致的。</p>
<p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。会出现以下两种问题（前一个要素成果的前提下）</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/85db53cc1932427384b72b0d19c874e9.png" alt="img"></p>
<p>我们在项目中用的是第二种情况，即先更新数据库值，然后删除缓存，如图：</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/c3ddb3c2237e4b70b7bbcaafdfcbde5e.png" alt="img"> <strong>为什么不选择先删除缓存的主要原因是有可能导致请求因缓存缺失而访问数据库，给数据库带来压力</strong></p>
<p><strong>如何解决数据不一致问题？</strong></p>
<p> 缓存和数据库的数据不一致一般是由两个原因导致的，提供了相应的解决方案。</p>
<ol>
<li>删除缓存值或更新数据库失败而导致数据不一致，可以使用重试机制确保删除或更新操作成功。</li>
<li>在删除缓存值、更新数据库的这两步操作中，有<strong>其他线程的并发读操作</strong>，导致其他线程读取到旧值，应对方案是延迟双删。</li>
</ol>
<p>重试机制：具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中。当应用没有能够成功地删除缓存值或者是更新数据库值时，<strong>可以从消息队列中重新读取这些值</strong>，然后<strong>再次进行删除或更新</strong>。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了 。</p>
<p>延迟双删： 一般应用于<strong>先删除缓存，再更新数据库的多线程并发访问的情况</strong>。这是因为，<strong>先更新数据库值，再删除缓存值的情况下，</strong>如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取<strong>旧值</strong>。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，<strong>其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值</strong>。所以，这种情况对业务的影响较小。</p>
<p>而假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</p>
<ol>
<li>线程 B 读取到了旧值；</li>
<li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。</li>
</ol>
<p> 等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。</p>
<p>这种情况我们就用延迟双删来解决： <strong>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作</strong>。之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除，这样再有线程来读取，就不会出现我们上面所说的，线程A更新了数据库，却发现缓存值于数据库不一致的情况了。</p>
<p>总结如图：</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/b63b9d41e48d4208b19a450e8ea3ba36.png" alt="img"></p>
<p>13 项目中的kafka是怎么用的？</p>
<h4 id="kafka入门"><a href="#kafka入门" class="headerlink" title="kafka入门"></a>kafka入门</h4><p>Apache <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Kafka&spm=1001.2101.3001.7020">Kafka</a>是一个分布式流平台。一个分布式的流平台应该包含3点关键的能力：</p>
<ol>
<li>发布和订阅流数据流，类似于消息队列或者是企业消息传递系统</li>
<li>以容错的持久化方式存储数据流</li>
<li>处理数据流</li>
</ol>
<p>-应用：消息系统、日志收集、用户行为跟踪、流式处理</p>
<p>·kafka特点</p>
<p>-高吞吐量：处理TB级的海量数据</p>
<p>-消息持久化：持久化，将数据存储到硬盘上，而不仅仅存储在内存中，长久保存消息，存到硬盘中的读取速度远远小于内存，读写硬盘的效率高低取决于读取硬盘的方式，硬盘的顺序读写的效率是很高的，kafka保证对硬盘消息的读写都是顺序的；</p>
<p>-高可靠性：kafka是分布式部署，一台服务器挂了，还有别的，有容错机制</p>
<p>-高拓展性：集群的服务器不够时，可以扩展服务器，只需简单的配置</p>
<p>·kafka术语</p>
<p>-Broker：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%A1%E5%A4%AB%E5%8D%A1&spm=1001.2101.3001.7020">卡夫卡</a>的服务器，卡夫卡集群中的每一台服务器称为一个Broker</p>
<p>-Zookeeper：管理集群的软件，在使用卡夫卡时可以单独安装zookeeper或是内置zookeeper</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">消息队列</a>的实现方式：</p>
<p>****点对点的实现方式****：BlockingQueue，生产者将消息放入队列中，消费者从队列中取出数据，每个消息只会被一个消费者消费；</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/f2f680ec3600494299c1e91f2df8a2fc.png" alt="img"></p>
<p>消息发送者生产消息发送到消息队列中，然后消息接收者从消息队列中取出并且消费消息。消息被消费以后，消息队列中不再有存储，所以消息接收者不可能消费到已经被消费的消息。</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/8a9d503fbb884c7c9796cbdc18c23d39.png" alt="img"></p>
<p><strong>发布订阅模式</strong>：生产者将消息发布到某个位置，多个消费者可以同时订阅这个位置，该消息可以被多个消费者读取，</p>
<p>卡夫卡使用的就是发布订阅模式：生产者将消息发布到的区域就叫做topic，可以理解为一个文件夹</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/2d802be321764149adfffdab1c42d1e0.png" alt="img"></p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/e73ff00f11a3479c9d624dcbf140783f.png" alt="img"></p>
<p>-Partition：对主题的分区</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/5083c422c09946f8ac05d3e0ffebeecf.png" alt="img"></p>
<p>-Offset：消息在分区内存放的索引</p>
<p>-Leader Replica：副本，卡夫卡是分布式的，所以会对分区进行多个副本的重复</p>
<p>主副本：可以处理获取消息的请求</p>
<p>-Follower Replica：从副本只是备份数据，不会产生响应，当主副本挂了时，分布式会在所有的从副本中选择一个作为新的主副本</p>
<p>发送系统通知： —操作非常频繁，用户群体很多，需要考虑性能问题</p>
<p>·触发事件</p>
<p>定义三种不同的主题，将不同的触发事件包装成不同的消息，发布到对应的主题中，这样生产者线程可以继续发布消息，</p>
<p>此时消费者线程可以并发的读取消息，进行存储</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/ea3d1d928bde4d70a603a84ff182e7f3.png" alt="img"></p>
<p>-评论后，发布通知</p>
<p>-点赞后，发布通知</p>
<p>-关注后，发布通知</p>
<p>·处理事件</p>
<p>-封装事件对象</p>
<p>-开发事件的生产者</p>
<p>-开发事件的消费者</p>
<p>生产者：触发Event，封装了Topic以及userId、Entity等信息，调用sendMsg时，提取出event.Topic和JSONObject.toJSONString(Event)以content形式发送，进行调用即可； （主动触发，<em><strong>*在添加评论、关注和点赞时触发）*</strong></em></p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/0eec3f8ba0954d3687afc5a8416efb50.png" alt="img"></p>
<p>消费者：监听Topic，如果有新消息，就读取，record中获得到的是event里的json串，再恢复成event即可JSONObject.paresObject(record.value().toString,Event.class)；然后将相关属性，封装成message私信的形式，保存到数据库中，供给前端页面调用并显示。（<em><strong>*这里的消费就是将数据从消息队列存入数据库，被动触发，*</strong></em><em><strong>*kafka*</strong></em>****监听主题，有消息就自动消费****）</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/f2e6fc488af045daad6ffedf3624d779.png" alt="img"></p>
<h4 id="14-消息队列放到内存还是磁盘？放磁盘为什么还这么快？"><a href="#14-消息队列放到内存还是磁盘？放磁盘为什么还这么快？" class="headerlink" title="14 消息队列放到内存还是磁盘？放磁盘为什么还这么快？"></a>14 消息队列放到内存还是磁盘？放磁盘为什么还这么快？</h4><p>Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。</p>
<p>从数据写入和读取两方面分析，为什么Kafka速度这么快</p>
<p>写入数据：磁盘读写的快慢取决于你怎么使用它，也就是顺序读写或者随机读写。在顺序读写的情况下，磁盘的顺序读写速度和内存持平。因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I&#x2F;O，最喜欢顺序I&#x2F;O。为了提高读写硬盘的速度，Kafka就是使用顺序I&#x2F;O。</p>
<p>即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘 ，它充分利用了现代操作系统分页存储来利用内存提高I&#x2F;O效率。</p>
<p>读取数据：实现了零拷贝</p>
<h4 id="15-TrieTree前缀树介绍一下"><a href="#15-TrieTree前缀树介绍一下" class="headerlink" title="15 TrieTree前缀树介绍一下"></a>15 TrieTree前缀树介绍一下</h4><p>前缀树 是一种多叉树的树形数据结构，在项目中用于对敏感词进行过滤。</p>
<p>构造前缀树：第一层就存所有敏感词的第一个字符</p>
<p>前缀树特点是：1.根节点不包含任何信息 除了根节点的每个节点只包含一个字符，2.从根节点到某一个节点经过的路径，字符所连接的字符串就是这个节点所对应的字符串 3.每个节点的所有子节点包含的字符不同</p>
<p>如下图：</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/31ad977cf5b24ad0a5c349e697ce6e97.png" alt="img"></p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/04e865fe230343b7adaade228130adfe.png" alt="img"></p>
<p>过滤敏感词算法：</p>
<p>三个指针，一个指向树根（node），另两个指针（begin和position），都指向文本首，其中一个一直向后移动（begin），另一个跟着动，发现不是敏感词，就说明以begin开头的字符不可能组成敏感词，将其存入StringBuilder，begin后移，然后再返回至begin。若是敏感词，则替换，并另两个指针都后移，树指针指向根节点。</p>
<p><img src="/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/62300939d5e54ecf9629e201a9794772.png" alt="img"></p>
<pre><code class="java"> public String filter(String text) &#123;
        if (StringUtils.isBlank(text)) &#123;
            return null;
        &#125;
        // 指针1
        TrieNode tempNode = rootNode;
        // 指针2
        int begin = 0;
        // 指针3
        int position = 0;
        // 结果
        StringBuilder sb = new StringBuilder();
        while (position &lt; text.length()) &#123;
            char c = text.charAt(position);
            // 跳过符号
            if (isSymbol(c)) &#123;
                // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步
                if (tempNode == rootNode) &#123;
                    sb.append(c);
                    begin++;
                &#125;
                // 无论符号在开头或中间,指针3都向下走一步
                position++;
                continue;
            &#125;
            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) &#123;
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            &#125; else if (tempNode.isKeywordEnd()) &#123;
                // 发现敏感词,将begin~position字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            &#125; else &#123;
                // 检查下一个字符
                position++;
            &#125;
        &#125;
        // 将最后一批字符计入结果
        sb.append(text.substring(begin));
        return sb.toString();
    &#125;
</code></pre>
<p>后面参考大佬文章<a target="_blank" rel="noopener" href="http://t.csdn.cn/lZgH7">http://t.csdn.cn/lZgH7</a></p>

    </div>
    
    
    
    
    
    
    
	
	
	

</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 HARD の 空间
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Hard
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>



<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>




<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>


